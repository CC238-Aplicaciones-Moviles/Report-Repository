
<h3 align ="center">
Universidad Peruana de Ciencias Aplicadas
</h3>
<p align="center">
  <img src="Assets/upc_logo.png" alt="logo" width="200"/>
</p>


<h3 align="center">
Nombre del curso: Aplicaciones para Dispositivos Móviles
  <br> <br>
Carrera: Ingeniería de Software
  <br> <br>
Nombre del profesor: Eduardo Martin Reyes Rodriguez
  <br> <br>
NRC: 1813
  <br> <br>
"Informe de Trabajo Final"
  <br> <br>
Nombre de la Startup: WorkHub
  <br> <br>
Nombre del Producto: TaskMaster
  <br> <br>
<div align="center">
 <br> <br> --Integrantes--

| <div style="width:300px">Alumno</div> | <div style="width:125px">Código</div> |
|:-------------------------------------------:|:-------------------------------------------:|
|Bejarano Martínez Alvaro Leandro| U202311640|
|Luquillas Asto Omar| U20211G641|
|Olivera Barzola Eric Marlon |U202315032|
|Sandoval Paiva Valentino |U20211a962|
|Sarmiento Medina Loreley |U202310005|
Septiembre de 2025
</h3>
</div>

## Registro de Versiones del Informe
| Versión | Fecha      | Autor | Descripción de modificación |
|---------|------------|-------|------------------------------|
| TB1     | 08/09/2025 | Bejarano Martínez Alvaro Leandro      |   **Completar**|
| TB1     | 08/09/2025 |Luquillas Asto Omar| |
| TB1     | 08/09/2025 |     Olivera Barzola Eric Marlon    |  Desarrollo de los ítems: 1.1.1 Descripción de la Startup, 1.1.2 Perfiles de integrantes del equipo, 1.2.1 Nombre del producto |
| TB1     | 08/09/2025 |Sandoval Paiva Valentino||
| TB1     | 08/09/2025 |Sarmiento Medina Loreley||
| TB1     | 17/09/2025 |     Olivera Barzola Eric Marlon    |  Desarrollo de User Stories, Impact Map, Product Backlog |
## Project Report Collaboration Insights

|  URL del repositorio del reporte  |
| :-----------------------------------: |
| [https://github.com/CC238-Aplicaciones-Moviles/Report-Repository.git](https://github.com/CC238-Aplicaciones-Moviles/Report-Repository.git) |

TB1:

S

e presenta capturas 
en imagen de los analíticos de colaboración y commits en GitHub para el repositorio 
del informe, realizados por los miembros del equipo


## Contenido

- [Student Outcome](#student-outcome)

- [Objetivos SMART](#objetivos-SMART)

- [Capítulo I: Presentación](#capítulo-i-presentacion)
  - [1.1. Startup Profile](#11-startup-profile)
    - [1.1.1. Descripción de la Startup](#111-descripción-de-la-startup)
    - [1.1.2. Perfiles de integrantes del equipo](#112-perfiles-de-integrantes-del-equipo)
  - [1.2. Solution Profile](#12-solution-profile)
    - [1.2.1. Antecedentes y problemática](#121-antecedentes-y-problemática)
    - [1.2.2. Lean UX Process](#122-lean-ux-process)
      - [1.2.2.1. Lean UX Problem Statements](#1221-lean-ux-problem-statements)
      - [1.2.2.2. Lean UX Assumptions](#1222-lean-ux-assumptions)
      - [1.2.2.3. Lean UX Hypothesis Statements](#1223-lean-ux-hypothesis-statements)
      - [1.2.2.4. Lean UX Canvas](#1224-lean-ux-canvas)
  - [1.3. Segmentos Objetivo](#13-segmentos-objetivo)
- [Capítulo II: Requirements Elicitation & Analysis](#capítulo-ii-requirements-elicitation--analysis)
  - [2.1. Competidores](#21-competidores)
    - [2.1.1. Análisis competitivo](#211-análisis-competitivo)
    - [2.1.2. Estrategias y tácticas frente a competidores](#212-estrategias-y-tácticas-frente-a-competidores)
  - [2.2. Entrevistas](#22-entrevistas)
    - [2.2.1. Diseño de entrevistas](#221-diseño-de-entrevistas)
    - [2.2.2. Registro de entrevistas](#222-registro-de-entrevistas)
    - [2.2.3. Análisis de entrevistas](#223-análisis-de-entrevistas)
  - [2.3. Needfinding](#23-needfinding)
    - [2.3.1. User Personas](#231-user-personas)
    - [2.3.2. User Task Matrix](#232-user-task-matrix)
    - [2.3.3. User Journey Mapping](#233-user-journey-mapping)
    - [2.3.4. Empathy Mapping](#234-empathy-mapping)
    - [2.3.5. Ubiquitous Language](#235-ubiquitous-language)
  - [2.4. Requirements specification](#24-requirements-specification)
    - [2.4.1. User Stories](#241-user-stories)
    - [2.4.2. Impact Mapping](#242-impact-mapping)
    - [2.4.3. Product Backlog](#243-product-backlog)
  - [2.5. Strategic-Level Domain-Driven Design](#25-strategic-level-domain-driven-design)
     - [2.5.1. EventStorming](#251-eventstorming)
       - [2.5.1.1. Candidate Context Discovery](#2511-candidate-context-discovery)
       - [2.5.1.2. Domain Message Flows Modeling](#2512-domain-message-flows-modeling)
       - [2.5.1.3. Bounded Context Canvases](#2513-bounded-context-canvases)
    - [2.5.2. Context Mapping](#252-context-mapping)
    - [2.5.3. Software Architecture](#253-software-architecture)
      - [2.5.3.1. Software Architecture Context Level Diagrams](#2531-software-architecture-context-level-diagrams)
      - [2.5.3.2. Software Architecture Container Level Diagrams](#2532-software-architecture-container-level-diagrams)
      - [2.5.3.3. Software Architecture Deployment Level Diagrams](#2533-software-architecture-deployment-level-diagrams)
  - [2.6. Tactical-Level Domain-Driven Design](#26-tactical-level-domain-driven-design)
    - [2.6.1. Bounded Context: Registro y Autenticación de Usuario](#261-bounded-context-registro-y-autenticación-de-usuario)
      - [2.6.1.1. Domain Layer](#2611-domain-layer)
      - [2.6.1.2. Interface Layer](#2612-interface-layer)
      - [2.6.1.3. Application Layer](#2613-application-layer)
      - [2.6.1.4. Infrastructure Layer](#2613-infrastructure-layer)
      - [2.6.1.5. Bounded Context Software Architecture Component Level Diagrams](#2613-bounded-context-software-architecture-component-level-diagrams)
      - [2.6.1.6. Bounded Context Software Architecture Code Level Diagrams](#2613-bounded-context-software-architecture-code-level-diagrams)
          - [2.6.1.6.1. Bounded Context Domain Layer Class Diagrams](#2613-bounded-context-domain-layer-class-diagrams)
          - [2.6.1.6.2. Bounded Context Database Design Diagrams](#2613-bounded-context-database-design-diagrams)
    - [2.6.2. Bounded Context: Analítica y Reportes](#262-bounded-context-analítica-y-reportes)
      - [2.6.2.1. Domain Layer](#2621-domain-layer)
      - [2.6.2.2. Interface Layer](#2622-interface-layer)
      - [2.6.2.3. Application Layer](#2623-application-layer)
      - [2.6.2.4. Infrastructure Layer](#2624-infrastructure-layer)
      - [2.6.2.5. Bounded Context Software Architecture Component Level Diagrams](#2625-bounded-context-software-architecture-component-level-diagrams)
      - [2.6.2.6. Bounded Context Software Architecture Code Level Diagrams](#2626-bounded-context-software-architecture-code-level-diagrams)
          - [2.6.2.6.1. Bounded Context Domain Layer Class Diagrams](#26261-bounded-context-domain-layer-class-diagrams)
          - [2.6.2.6.2. Bounded Context Database Design Diagrams](#26262-bounded-context-database-design-diagrams)
    - [2.6.3. Bounded Context: Visualización y Seguimiento](#263-bounded-context-visualización-y-seguimiento)
      - [2.6.3.1. Domain Layer](#2631-domain-layer)
      - [2.6.3.2. Interface Layer](#2632-interface-layer)
      - [2.6.3.3. Application Layer](#2633-application-layer)
      - [2.6.3.4. Infrastructure Layer](#2634-infrastructure-layer)
      - [2.6.3.5. Bounded Context Software Architecture Component Level Diagrams](#2635-bounded-context-software-architecture-component-level-diagrams)
      - [2.6.3.6. Bounded Context Software Architecture Code Level Diagrams](#2636-bounded-context-software-architecture-code-level-diagrams)
          - [2.6.3.6.1. Bounded Context Domain Layer Class Diagrams](#26361-bounded-context-domain-layer-class-diagrams)
          - [2.6.3.6.2. Bounded Context Database Design Diagrams](#26362-bounded-context-database-design-diagrams)
    - [2.6.4. Bounded Context:  Gestión de Proyectos y Tareas](#264-bounded-context-gestión-de-proyectos-y-tareas)
      - [2.6.4.1. Domain Layer](#2641-domain-layer)
      - [2.6.4.2. Interface Layer](#2642-interface-layer)
      - [2.6.4.3. Application Layer](#2643-application-layer)
      - [2.6.4.4. Infrastructure Layer](#2644-infrastructure-layer)
      - [2.6.4.5. Bounded Context Software Architecture Component Level Diagrams](#2645-bounded-context-software-architecture-component-level-diagrams)
      - [2.6.4.6. Bounded Context Software Architecture Code Level Diagrams](#2646-bounded-context-software-architecture-code-level-diagrams)
          - [2.6.4.6.1. Bounded Context Domain Layer Class Diagrams](#26461-bounded-context-domain-layer-class-diagrams)
          - [2.6.4.6.2. Bounded Context Database Design Diagrams](#26462-bounded-context-database-design-diagrams)
    - [2.6.5. Bounded Context: Notificaciones](#265-bounded-context-notificaciones)
      - [2.6.5.1. Domain Layer](#2651-domain-layer)
      - [2.6.5.2. Interface Layer](#2652-interface-layer)
      - [2.6.5.3. Application Layer](#2653-application-layer)
      - [2.6.5.4. Infrastructure Layer](#2654-infrastructure-layer)
      - [2.6.5.5. Bounded Context Software Architecture Component Level Diagrams](#2655-bounded-context-software-architecture-component-level-diagrams)
      - [2.6.5.6. Bounded Context Software Architecture Code Level Diagrams](#2656-bounded-context-software-architecture-code-level-diagrams)
          - [2.6.5.6.1. Bounded Context Domain Layer Class Diagrams](#26561-bounded-context-domain-layer-class-diagrams)
          - [2.6.5.6.2. Bounded Context Database Design Diagrams](#26562-bounded-context-database-design-diagrams)
- [Conclusiones](#conclusiones)
- [Bibliografía](#bibliografía)
- [Anexos](#anexos)

## Student Outcome
El curso contribuye al cumplimiento del Student Outcome ABET:
**ABET - EAC - Student Outcome 7 Criterio**: La capacidad de adquirir y aplicar nuevos conocimientos según sea
necesario, utilizando estrategias deaprendizaje apropiadas.
En elsiguiente cuadro se describe las accionesrealizadas y enunciados de conclusiones por parte del grupo, que permiten sustentar el haber alcanzado los criterios especificos.

 | Criterio específico                                                                                                                     | Acciones realizadas                                                                                                                                                                                                         | Conclusiones                                                                                                                                                                                                                                                                                                                        |
| --------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Actualiza conceptos y conocimientos necesarios para su desarrollo profesional y en especial para su proyecto en soluciones de software. | - **Bejarano Martínez, Álvaro Leandro**<br>**TB1**<br>- Luquillas Asto, Omar<br>**TB1**<br>- Olivera Barzola, Eric Marlon<br>**TB1**<br>- Sandoval Paiva Valentino<br>**TB1**<br>- Sarmiento Medina, Loreley<br>**TB1**<br> | La elaboración del proyecto permitió reforzar y aplicar conceptos clave en arquitectura de software, metodologías ágiles y diseño de soluciones, fortaleciendo competencias técnicas que son directamente aplicables en la formación profesional y en la práctica de proyectos reales en soluciones de software.                    |
| Reconoce la necesidad del aprendizaje permanente para el desempeño profesional y el desarrollo de proyectos en soluciones de software.  | - **Bejarano Martínez, Álvaro Leandro**<br>**TB1**<br>- Luquillas Asto, Omar<br>**TB1**<br>- Olivera Barzola, Eric Marlon<br>**TB1**<br>- Sandoval Paiva Valentino<br>**TB1**<br>- Sarmiento Medina, Loreley<br>**TB1**<br> | Durante el desarrollo del proyecto se evidenció la importancia de la investigación continua y la adaptación a nuevas herramientas y enfoques, lo que refuerza la necesidad de mantener un aprendizaje constante para enfrentar los retos que plantea el mercado tecnológico y asegurar la mejora continua en el ámbito profesional. |
 

<hr>

## Objetivos SMART
ncorporar una sección en una nueva página, situada después de la sección Student 
Outcome, donde cada miembro del equipo de trabajo formule un plan que incluya al 
menos dos objetivos SMART. Estos objetivos deben centrarse en el desarrollo 
profesional de cada estudiante una vez finalizada su carrera. El propósito es que los 
objetivos reflejen de manera clara y medible cómo cada integrante planea alcanzar un 
crecimiento profesional continuo tras su graduación. 

<h3>Eric Marlon Olivera Barzola

  Objetivo 1: Publicar una aplicación móvil propia en la Play Store dentro del primer año.
  Objetivo 2: Obtener una certificación en desarrollo móvil (Android o iOS) en un plazo máximo de 18 meses.
  
  
  - Esto falta completareqweqweqwe
  - dasdasdas

<h3> Loreley Sarmiento Medina

- **Objetivo 1: Convertirme en desarrolladora mobile certificada**
  - **Específico:** Obtener una certificación en desarrollo de aplicaciones móviles (Android/iOS) y crear al menos 2 aplicaciones publicadas en tiendas oficiales.  
  - **Medible:** Publicar 2 aplicaciones móviles funcionales y obtener al menos 500 descargas en conjunto.  
  - **Alcanzable:** Dedicar 10 horas semanales a cursos especializados y práctica de programación mobile.  
  - **Relevante:** Permitirá fortalecer mi perfil profesional y abrir oportunidades laborales en el sector tecnológico.  
  - **Tiempo:** Lograr la certificación y publicación de apps dentro de los 24 meses posteriores a la graduación.  

- **Objetivo 2: Desarrollar una solución de IA aplicada a ciencia de datos**
  - **Específico:** Diseñar y poner en marcha una IA que procese y analice grandes volúmenes de datos para generar modelos predictivos aplicables a proyectos de negocio.  
  - **Medible:** Construir un prototipo funcional con al menos 3 modelos predictivos validados con datasets reales.  
  - **Alcanzable:** Participar en un programa de especialización en IA y destinar 12 horas semanales a investigación y desarrollo.  
  - **Relevante:** Permitirá integrar el análisis de datos con inteligencia artificial para la toma de decisiones estratégicas.  
  - **Tiempo:** Completar el prototipo en un plazo máximo de 2 años después de la graduación.  

## Capítulo I: Presentación  
### 1.1. Startup Profile  

En muchas empresas, los proyectos se gestionan de manera desordenada utilizando múltiples herramientas desconectadas como Excel, correos y chats. Esto genera duplicidad de esfuerzos, falta de visibilidad del progreso y dificultades para controlar los recursos financieros. Frente a esta realidad, nace nuestra startup, una organización que busca transformar la forma en que los equipos trabajan y colaboran, brindándoles soluciones tecnológicas que simplifiquen la gestión de proyectos.

Nuestra propuesta surge también de la necesidad de que la gestión empresarial sea más accesible y flexible, especialmente en un entorno donde los profesionales están cada vez más conectados desde sus dispositivos móviles. Por ello, creemos firmemente que la gestión de proyectos debe poder realizarse desde la palma de la mano, sin depender únicamente de un escritorio u oficina.

#### 1.1.1. Descripción de la Startup  

Nuestra empresa se dedica al desarrollo de soluciones digitales que transformen la manera en que los equipos gestionan sus proyectos y recursos. Nos enfocamos en pequeñas y medianas empresas que necesitan herramientas accesibles y efectivas, evitando la complejidad y los altos costos de otras alternativas.

Por ello, desarrollamos TaskMaster, una plataforma digital de gestión de proyectos colaborativos empresariales diseñada para optimizar la organización, asignación y supervisión de tareas en equipos de trabajo. Integra herramientas visuales como tableros Kanban, calendarios y métricas de desempeño, además de un módulo financiero que permite controlar presupuestos, gastos y pagos en tiempo real.

**Objetivo:**
Brindar a las empresas una solución centralizada que facilite la planificación, ejecución y control de proyectos, mejorando la eficiencia, la colaboración entre equipos y la gestión de recursos.

**Misión**
Facilitar a las organizaciones la gestión de proyectos mediante una plataforma intuitiva y colaborativa que integre tanto la productividad del equipo como el control financiero, impulsando la eficiencia y la transparencia.

**Visión**
Convertirnos en la organización líder en Latinoamérica en el desarrollo de soluciones móviles de gestión de proyectos empresariales, reconocida por su capacidad de simplificar la colaboración y aportar valor estratégico en la toma de decisiones.

#### 1.1.2. Perfiles de integrantes del equipo  
|                             | Miembros del equipo        | Código de Estudiante |          Descripción            |
|------------------| ----------------------------------------------- | ----------------- | ---------------------- |
|![Imagen1](Assets/TB1/)      |Eric Marlon Olivera Barzola | U202315032 |   Soy Eric Marlon Olivera Barzola, estudiante de Ingeniería de Software del séptimo ciclo, con un interés particular en la ciberseguridad. A lo largo de mi formación he adquirido experiencia en diferentes lenguajes de programación como C#, C++ y Java. Me motiva desarrollar soluciones que no solo sean funcionales, sino que también transmitan confianza y seguridad a los usuarios.  |
|![Imagen2](Assets/TB1/)      |Omar Luquillas Asto         | U20211G641 | Soy estudiante de la carrera de Ingeniería de Software. Elegí esta carrera porque me apasiona la tecnología, el desarrollo de software y la programación. Tengo conocimientos en lenguajes de programación como C++, Python y Java. Me considero una persona investigadora, ya que me gusta aprender cosas nuevas y siempre estoy en busca de soluciones creativas e innovadoras que generen un impacto positivo en la vida de las personas. Además, valoro el trabajo en equipo, soy responsable y me comprometo a cumplir con mis tareas de manera eficiente. |
|![Imagen3](Assets/TB1/Valentino.png)      | Valentino Sandoval Paiva                           |  U20211A962     |    Soy Valentino Sandoval, tengo 20 años y soy estudiante de la carrera de Ingeniería de Software. Tengo conocimiento en lenguajes de programación como python y c++, y bases de datos como SQLServer y MongoDB. Desde pequeño me sentí atraído por la tecnología, por lo que me decidí a estudiar la carrera, además disfruto de jugar videojuegos con amigos en mi tiempo libre.     |
|![Imagen4](Assets/TB1/)      |                            |       |         |
|![Imagen5](Assets/TB1/Loreleyimagen.jpg)      | Loreley Sarmiento Medina   | U202310005 | Me interesa el desarrollo frontend, principalmente con Angular, creando interfaces dinámicas y centradas en el usuario. Utilizo herramientas como GitHub para organizar proyectos y colaborar en equipo, y me motiva aprender constantemente nuevas tecnologías que fortalezcan mis capacidades técnicas.Además, destaco por mis habilidades blandas, como el trabajo en equipo, la adaptabilidad y la comunicación efectiva, que me permiten integrarme fácilmente en proyectos multidisciplinarios. Soy una persona responsable, proactiva y creativa, cualidades que me impulsan a asumir retos y aportar soluciones que sumen al desarrollo integral del producto. |

### 1.2. Solution Profile 

En muchas empresas, los proyectos se gestionan de manera desordenada utilizando múltiples herramientas desconectadas (Excel, correos, chats). Esto genera duplicidad de esfuerzos, falta de visibilidad del progreso y dificultades para controlar los recursos financieros asociado.

- **La solución debe abordar principalmente:**

  - Elaboración de la gestión de proyectos: unificar tareas, cronogramas y comunicación en un solo espacio.
  - Colaboración en tiempo real: permitir que los miembros actualicen avances y reciban notificaciones inmediatas.
  - Asignación de responsabilidades: con roles definidos (jefes de proyecto y miembros).
  - Seguimiento del progreso: mediante tableros visuales y calendarios.


- **Restricciones y Alcance**

  - Restricciones técnicas: la plataforma debe ser accesible desde dispositivos móvile, con una interfaz intuitiva y adaptable.
  - Alcance inicial: orientada a pequeñas y medianas empresas que requieren optimizar la gestión de proyectos sin recurrir a soluciones costosas y complejas.
  - Limitación funcional inicial: el módulo financiero se centrará en presupuestos y pagos básicos, con posibilidad de ampliación en futuras versiones.


#### 1.2.1. Antecedentes y problemática  

En el entorno empresarial actual, las organizaciones suelen depender de múltiples herramientas dispersas —como hojas de cálculo, correos electrónicos, aplicaciones de mensajería y sistemas separados para finanzas o planificación— lo que genera una gestión de proyectos fragmentada. Esta dispersión provoca una pérdida considerable de tiempo, disminución de productividad y, en muchos casos, pérdida de ingresos. Un informe de Quickbase (2023) encontró que los sistemas fragmentados son responsables de graves impactos en la eficiencia organizacional y los resultados financieros. Además, Atlassian (2024) observa que el 56 % de los trabajadores del conocimiento sufren flujos de trabajo desconectados por variaciones en la forma de seguimiento del trabajo, lo que obstaculiza la visibilidad y la colaboración eficaz.

**1. What / ¿QUÉ?**

¿Cuál es el problema?<br><br>
Las empresas utilizan múltiples herramientas desconectadas como Excel, correos, mensajería instantánea para gestionar proyectos. Esto genera fragmentación, duplicidad de información, retrasos y pérdida de visibilidad sobre el progreso y los costos.

¿Cuál es la relación con la persona en cuestión?<br><br>
Los líderes de proyecto enfrentan dificultad para coordinar tareas y controlar recursos, mientras que los colaboradores gastan tiempo buscando información y actualizando manualmente avances en distintas plataformas.

**2. When / ¿CUÁNDO?**

¿Cuándo sucede el problema?<br><br>
De forma constante durante el ciclo de vida de los proyectos, especialmente en la planificación, el seguimiento de avances y el control financiero.

¿Cuándo utiliza el cliente el producto?<br><br>
El cliente (líder o miembro de equipo) utiliza TaskMaster diariamente, tanto en la asignación/ejecución de tareas como en la revisión de métricas y reportes.

**3. Where / ¿DÓNDE?**

¿Dónde está el cliente cuando usa el producto?<br><br>
En entornos de oficina, en modalidad híbrida o trabajo remoto. El producto se usa principalmente desde computadoras y dispositivos móviles.

¿Dónde surge el problema?<br><br>
En la dispersión digital: cuando la información está repartida en varias aplicaciones no integradas.

**4. Who / ¿QUIÉN?**

¿Quiénes se ven involucrados en el problema?<br>

Jefes de proyecto → responsables de coordinar equipos y controlar resultados.
Miembros de equipo → encargados de ejecutar tareas y reportar avances.


¿Cuáles son las causas del problema?<br>
  - Uso de demasiadas aplicaciones sin integración.
  - Dependencia de procesos manuales.
  - Falta de visibilidad centralizada en la gestión de proyectos.

**5. Why / ¿POR QUÉ?**
¿Por qué sucede el problema? 

Porque las empresas suelen adoptar herramientas aisladas que resuelven problemas específicos (calendarios, chats, finanzas, gestión de tareas), pero no integran toda la operación en un mismo ecosistema.

Esto genera duplicidad, trabajo extra y decisiones basadas en información incompleta.

**6. How / ¿CÓMO?**

¿En qué condiciones los clientes usan nuestro producto? <br><br>
En entornos de proyectos colaborativos, con equipos distribuidos, necesidad de comunicación rápida y presión por cumplir plazos y presupuestos.

¿Cómo se diferencia el problema del estado normal (óptimo)? <br><br>
En un estado óptimo, la gestión debería ser fluida, centralizada y con datos actualizados en tiempo real. Actualmente, existe fricción por la fragmentación de sistemas.

**7. How Much / ¿CUÁNTO?**

¿Cuántos problemas se dan en un día, una semana o un mes? <br><br>
Según Quickbase (2023), el 70 % de los empleados pierde hasta 20 horas por semana debido a sistemas fragmentados. Esto equivale a medio tiempo laboral desperdiciado por cada trabajador.

¿Cuánto dinero están implicando? <br><br>
Atlassian (2024) reporta que las organizaciones con ecosistemas desconectados tienen un 37 % menos probabilidad de cumplir sus metas de ingresos. Además, Forrester (2024) encontró que el 76 % de las PMOs usan cinco o más herramientas por proyecto, generando pérdidas de hasta un 23 % del tiempo semanal en tareas redundantes.


#### 1.2.2. Lean UX Process  

Según Pragma (2021), el proceso Lean UX es la mezcla de metodologías ágiles y temas de usabilidad, donde se prioriza la experiencia de usuario por la creación de un producto. Teniendo en cuenta ello, hemos elaborado nuestro Lean UX process basándonos en sus cuatro pilares principales: problem statements, assumptions, hypothesis y canvas.

##### 1.2.2.1. Lean UX Problem Statements

**Problem Statement #1 – Jefes de Proyecto**

Nuestra plataforma busca brindar a los jefes de proyecto una herramienta centralizada que integre la asignación de tareas, el seguimiento de avances y la gestión financiera, garantizando mayor control y visibilidad en sus proyectos.Hemos identificado que los jefes de proyecto enfrentan dificultades para coordinar equipos cuando la información está dispersa en múltiples herramientas (hojas de cálculo, correos, chats y sistemas financieros independientes). Esta situación provoca retrasos, duplicación de esfuerzos, falta de transparencia en el uso de recursos y complicaciones en la toma de decisiones.

Ante este desafío, surge la pregunta clave: ¿Cómo podemos garantizar que los jefes de proyecto tengan un espacio centralizado para coordinar equipos, supervisar avances y controlar finanzas de manera eficiente y en tiempo real?

**Problem Statement #2 – Miembros de Equipo**

Nuestra plataforma busca ofrecer a los miembros de equipo un espacio único y sencillo donde puedan visualizar sus tareas, plazos y prioridades, colaborando de forma más ágil y organizada.
Hemos identificado que los colaboradores suelen perder tiempo al cambiar entre diferentes canales de comunicación y hojas de cálculo, lo que genera confusión en responsabilidades, olvidos de plazos y baja productividad. Esta dispersión afecta el rendimiento individual y colectivo, además de impactar negativamente en la satisfacción y el clima laboral.

Ante este desafío, surge la pregunta clave: ¿Cómo podemos brindar a los miembros de equipo una herramienta unificada que simplifique la organización de tareas, reduzca la confusión y fomente la colaboración efectiva en los proyectos?

##### 1.2.2.2. Lean UX Assumptions

**Business Assumptions (Suposiciones de Negocio)**

- Creo que mis clientes tienen la necesidad de: Centralizar la gestión de proyectos en una sola plataforma, evitando el uso disperso de herramientas como Excel, correos y chats.
- Estas necesidades se pueden resolver con: Una plataforma digital colaborativa que integre tableros Kanban, calendarios, asignación de tareas, métricas de desempeño y un módulo financiero básico.
- Mis clientes iniciales son (o serán): Pequeñas y medianas empresas con equipos de desarrollo o áreas de proyectos que buscan mejorar la organización y el control de sus recursos.
- El valor principal que los clientes quieren obtener de mi servicio es: Mayor eficiencia y visibilidad en la planificación y ejecución de proyectos.
Beneficios adicionales que también pueden obtener: Mejor colaboración entre miembros, reducción de errores, control de presupuestos y reportes para decisiones estratégicas.
- Adquiriré a la mayoría de mis clientes a través de: Estrategias de marketing digital (redes sociales, LinkedIn), demostraciones gratuitas de la plataforma y recomendaciones entre contactos en el sector empresarial.
- Ganaré dinero mediante: Un modelo de licenciamiento, con una versión gratuita limitada y planes de pago según el tamaño de la empresa o número de miembros y sus necesidades.
- Mi principal competencia en el mercado será: Algunas competencias serán las plataformas similares como Trello, Asana, o Jira.
Los superaremos debido a: Un enfoque en la integración financiera simple, precios más accesibles para pymes y una interfaz intuitiva que no requiera mucha capacitación.
- Mi mayor riesgo de producto es: Que las empresas perciban a TaskMaster como una herramienta redundante frente a soluciones ya conocidas.
Lo resolveremos mediante: Diferenciación en la propuesta de valor (finanzas integradas + simplicidad) y versiones de prueba gratuitas para demostrar beneficios reales.
- Otras suposiciones que, si resultan falsas, harán que nuestro proyecto fracase:
  - Que las pymes estén dispuestas a pagar por una solución digital en lugar de continuar con herramientas gratuitas.
  - Que los usuarios puedan adoptar rápidamente la plataforma sin necesidad de largos procesos de capacitación.

**User Assumptions (Suposiciones de Usuario)**

- ¿Quién es el usuario?: Nuestros usuarios serán líderes o gerentes de empresas como Product Owners, Scrum Masters o jefes de proyectos y los miembros de equipos de desarrollo o colaboradores en proyectos empresariales.
- ¿Dónde encaja nuestro producto en su trabajo o vida?: Dentro del entorno laboral, como herramienta diaria de planificación, asignación y seguimiento de tareas.
- ¿Qué problemas resuelve nuestro producto?: Nuestro producto resuelve los siguientes problemas.
  -	La dispersión de información entre múltiples canales.
  -	La falta de visibilidad sobre el progreso del proyecto.
  -	Las dificultades para controlar recursos financieros y plazos.
- ¿Cuándo y cómo se usa nuestro producto?: Se utiliza de forma continua durante la jornada laboral, principalmente desde computadoras o dispositivos móviles, para registrar avances, asignar tareas y revisar métricas de desempeño.
- ¿Qué características son importantes?: Las características más importantes de nuestro producto son.
  -	Seguimiento del progreso mediante tableros Kanban.
  -	Asignación clara de tareas y roles.
  -	Colaboración en tiempo real.
  -	Reportes de progreso y métricas.
  -	Módulo financiero básico (presupuestos y pagos).
- ¿Cómo debería verse y comportarse nuestro producto?: Debe tener una interfaz moderna, intuitiva y fácil de aprender, con navegación clara, diseño adaptable (responsive) y elementos visuales que permitan identificar avances y pendientes de un vistazo.

##### 1.2.2.3. Lean UX Hypothesis Statements

Hypothesis Statement 01:

- Creemos que centralizar las tareas, cronogramas y comunicación en una sola plataforma para pymes aumentará la eficiencia de sus equipos de trabajo.
- Sabremos que estamos en lo correcto cuando veamos que más del 70 % de los usuarios reporten menos uso de herramientas externas como Excel o chats dispersos.

Hypothesis Statement 02:

- Creemos que implementar tableros Kanban y calendarios interactivos para líderes de proyectos mejorará la visibilidad del progreso.
- Sabremos que estamos en lo correcto cuando recibamos retroalimentación positiva en encuestas y un aumento en la frecuencia de consulta de estos módulos.

Hypothesis Statement 03:

- Creemos que ofrecer un módulo financiero básico (presupuestos y pagos) para gerentes facilitará el control de recursos.
- Sabremos que estamos en lo correcto cuando observemos que al menos el 60 % de los clientes activos utilizan regularmente el módulo financiero.

Hypothesis Statement 04:

- Creemos que una interfaz intuitiva y fácil de usar acelerará la adopción de la plataforma.
- Sabremos que estamos en lo correcto cuando nuevos usuarios completen su primera tarea en menos de 10 minutos de uso.

Hypothesis Statement 05:

- Creemos que ofrecer una versión de prueba gratuita aumentará la tasa de conversión a clientes de pago.
- Sabremos que estamos en lo correcto cuando al menos el 30 % de los usuarios de prueba pasen a un plan de suscripción.

Hypothesis Statement 06:

- Creemos que integrar métricas de desempeño para líderes de proyectos mejorará la toma de decisiones estratégicas.
- Sabremos que estamos en lo correcto cuando los usuarios reporten mayor confianza al presentar reportes a sus superiores.

Hypothesis Statement 07:

- Creemos que la posibilidad de asignar roles claros (jefe de proyecto, miembro) aumentará la organización interna.
- Sabremos que estamos en lo correcto cuando disminuya el número de tareas duplicadas o sin responsable asignado.

Hypothesis Statement 08:

- Creemos que permitir el acceso desde dispositivos móviles incrementará la frecuencia de uso diario.
- Sabremos que estamos en lo correcto cuando veamos que más del 50 % de las sesiones provienen de smartphones o tablets.

Hypothesis Statement 09:

- Creemos que un precio accesible y escalable atraerá a pequeñas y medianas empresas frente a competidores más costosos.
- Sabremos que estamos en lo correcto cuando los clientes comparen TaskMaster favorablemente con Asana o Jira en entrevistas cualitativas.

Hypothesis Statement 10:

- Creemos que brindar reportes automáticos de avance reducirá la carga administrativa de los líderes.
- Sabremos que estamos en lo correcto cuando los usuarios indiquen que ya no necesitan generar reportes manuales en Excel.

Hypothesis Statement 11:

- Creemos que el diseño visual atractivo y moderno motivará un uso más constante de la plataforma.
- Sabremos que estamos en lo correcto cuando los usuarios activos se conecten al menos 3 veces por semana.

Hypothesis Statement 12:

- Creemos que los recordatorios automáticos de vencimientos ayudarán a reducir retrasos en los proyectos.
- Sabremos que estamos en lo correcto cuando el porcentaje de tareas finalizadas en fecha aumente mes a mes.

Hypothesis Statement 13:

- Creemos que el soporte técnico rápido y accesible aumentará la satisfacción del cliente.
- Sabremos que estamos en lo correcto cuando la calificación promedio de soporte sea superior a 4/5.

Hypothesis Statement 14:

- Creemos que la segmentación de proyectos por áreas o departamentos facilitará la organización en empresas con varios equipos.
- Sabremos que estamos en lo correcto cuando las empresas medianas gestionen más de 2 proyectos simultáneamente en la plataforma.

Hypothesis Statement 15:

- Creemos que la seguridad en el manejo de datos financieros incrementará la confianza de los clientes.
- Sabremos que estamos en lo correcto cuando no tengamos reportes de incidentes graves y los usuarios destaquen positivamente la seguridad en encuestas.

##### 1.2.2.4. Lean UX Canvas

<img src="./Assets/TB1/LeanUXCanvas.png" alt="Lean UX Canvas">

### 1.3. Segmentos Objetivo

**Segmento Objetivo 1: Líder o Gerente de Empresa**

Este segmento corresponde a profesionales que ocupan cargos de liderazgo dentro de organizaciones del sector tecnológico o empresarial, tales como gerentes de proyectos, jefes de innovación o líderes de área. Su rol principal consiste en tomar decisiones estratégicas, gestionar recursos y coordinar equipos en proyectos de desarrollo ágil.

- **Características Demográficas:**

En general, suelen encontrarse en el rango de edad de 30 a 50 años, cuentan con estudios universitarios o de posgrado, y residen principalmente en centros urbanos como Lima, Arequipa o Trujillo, donde se concentra la mayor cantidad de empresas con proyectos tecnológicos.

- **Información Estadística de Sustento:**

Según el Informe del INEI (2023), el 65 % de las empresas medianas y grandes del Perú se ubican en Lima Metropolitana, siendo estas las que mayormente adoptan metodologías de gestión de proyectos ágiles. Asimismo, un estudio de Everis y EY (2022) señala que más del 40 % de las empresas peruanas del sector financiero y tecnológico ya han implementado roles asociados a Scrum Master y Product Owner, lo que refleja la creciente relevancia de este segmento para proyectos de desarrollo ágil.


**Segmento Objetivo 2: Equipo de Desarrollo de Proyectos**

Este segmento está conformado por profesionales que se desempeñan como programadores, diseñadores, analistas de sistemas o testers. Su rol es implementar soluciones técnicas, colaborar en la construcción de software y adaptarse a metodologías ágiles bajo la guía de los líderes de proyecto.

- **Características Demográficas:**

En su mayoría, son profesionales jóvenes entre 22 y 35 años, muchos de ellos egresados recientes o estudiantes de los últimos ciclos de carreras de ingeniería de software, sistemas o afines. Están ubicados principalmente en Lima y en regiones con polos tecnológicos como Cusco, Arequipa y La Libertad. Se caracterizan por un alto nivel de adopción tecnológica y el uso frecuente de herramientas colaborativas.

- **Información Estadística de Sustento:**

De acuerdo con el Banco Interamericano de Desarrollo (BID, 2021), en el Perú se proyecta una demanda de más de 30,000 profesionales de tecnologías de la información hacia el 2025. Asimismo, la Encuesta Nacional de Innovación en la Industria (INEI, 2022) señala que un 37 % de las empresas que desarrollan proyectos de innovación tecnológica han incorporado equipos de desarrollo de software en su estructura, lo cual evidencia la importancia de este grupo como segmento objetivo.

## Capítulo II: Requirements Elicitation & Analysis
### 2.1. Competidores  

En esta sección se expone un análisis de los principales competidores de WorkHub, poniendo el foco en aquellos que operan bajo modelos de negocio digitales similares o que, aunque no coincida por completo, ofrecen productos o servicios que se solapan parcialmente con nuestra propuesta. Se consideran tanto los competidores directos, que actúan en el mismo segmento de mercado, como los indirectos, que abarcan ámbitos relacionados con la organización de tareas, la planificación de actividades y la gestión colaborativa de equipos.

**1. Wrike**

**Descripción:**

Wrike es una plataforma de gestión de proyectos y trabajo colaborativo diseñada para equipos de distintos tamaños. Permite planificar, priorizar y dar seguimiento a tareas en tiempo real, con funcionalidades orientadas a mejorar la visibilidad del flujo de trabajo y la comunicación entre los miembros del equipo.

**Características principales:**
- Organización de proyectos mediante diagramas de Gantt, tableros Kanban, calendarios y listas.

- Creación de tareas, subtareas y dependencias para una planificación detallada.

- Colaboración centralizada con comentarios, menciones, archivos adjuntos y aprobaciones en línea.

- Automatización de flujos de trabajo y recordatorios para reducir tareas repetitivas.

- Reportes personalizables con métricas de desempeño y paneles de control en tiempo real.

- Integraciones con más de 400 herramientas, incluyendo Slack, Salesforce, Microsoft Teams y Google Workspace.

- Aplicación móvil con acceso a tareas, notificaciones y actualización de proyectos desde cualquier lugar.

**2. Trello**

**Descripción:**

Trello es una herramienta de gestión de proyectos basada en tableros Kanban, diseñada para facilitar la organización visual de tareas y proyectos. Su interfaz intuitiva y flexible lo convierte en una opción popular para equipos que buscan simplicidad y colaboración en tiempo real.

**Características principales:**

- Tableros, listas y tarjetas para organizar proyectos y tareas de forma visual.

- Personalización de tarjetas con etiquetas, fechas de vencimiento, checklists y archivos adjuntos.

- Colaboración en equipo mediante comentarios, menciones y notificaciones.

- Automatización de tareas con Butler (reglas, recordatorios y acciones automáticas).

- Integraciones con herramientas como Slack, Google Drive, Jira, Dropbox y más.

- Plantillas predefinidas para distintos tipos de proyectos y flujos de trabajo.

- Aplicación móvil con acceso completo a tableros y colaboración en cualquier lugar.

**3. ClickUp**

**Descripción:**

ClickUp es una plataforma de productividad y gestión de proyectos todo en uno que busca centralizar tareas, documentos, comunicación y seguimiento de objetivos en un solo lugar. Está pensada para equipos que necesitan una solución flexible y personalizable, adaptándose tanto a proyectos simples como a flujos de trabajo complejos.

**Características principales:**

- Organización de proyectos mediante listas, tableros Kanban, calendarios, cronogramas y diagramas de Gantt.

-Gestión detallada de tareas con subtareas, prioridades, dependencias y asignaciones múltiples.

- Colaboración en tiempo real con comentarios, menciones, chat integrado y documentos compartidos.

- Paneles de control e informes personalizables para monitorear productividad y avances.

- Funcionalidades de seguimiento de tiempo y estimaciones de esfuerzo.

- Automatización de procesos para reducir tareas repetitivas.

- Amplia integración con herramientas como Slack, GitHub, Zoom, Google Workspace, entre otras.

- Aplicación móvil y de escritorio con sincronización completa para trabajar desde cualquier dispositivo.

#### 2.1.1. Análisis competitivo  

| **Categoría** | **Nombre de las Startups o Empresas** | **Nuestra Startup** | **Competidor 1** | **Competidor 2** | **Competidor 3** |
|---------------|----------------------------------------|-------------|-----------|------------|-------------|
| **Perfil** | Overview | **WorkHub**  ![WorkHub](Assets/TB1/LOGO1.png) | **Wrike** ![Wrike](Assets/TB1/wrike.png) | **Trello** ![Trello](Assets/TB1/trello.png) | **ClickUp** ![ClickUp](Assets/TB1/cu.png) |
|  | Ventaja competitiva (valor para el cliente) | Interfaz intuitiva y sencilla, diseñada para ser usada antes, durante y después del ciclo de vida del desarrollo de software. | Análisis predictivos, automatización avanzada y colaboración en tiempo real para mejorar productividad y visibilidad de proyectos. | Interfaz visual e intuitiva, ideal para equipos pequeños y startups que buscan simplicidad. | Plataforma altamente personalizable, integra gestión de tareas, tiempo y recursos en un solo lugar. |
| **Perfil de Marketing** | Mercado Objetivo | Startups de tecnología que buscan eficiencia y colaboración en equipos de desarrollo. | Empresas medianas y grandes con proyectos complejos que requieren integración avanzada. | Equipos pequeños y startups que necesitan gestión visual y simple de proyectos. | Startups, pymes y empresas que buscan una solución flexible y completa de gestión. |
|  | Estrategias de Marketing | Marketing digital dirigido a comunidades tecnológicas, pruebas gratuitas y asociaciones estratégicas. | Posicionamiento como herramienta robusta y flexible, demostraciones personalizadas y enfoque en integraciones. | Estrategia enfocada en simplicidad y accesibilidad, resaltando su facilidad de uso e integraciones populares. | Estrategia como alternativa económica y todo-en-uno, con fuerte enfoque en personalización y escalabilidad. |
| **Perfil del Producto** | Productos y servicios | Plataforma colaborativa en tiempo real, con edición simultánea de documentos y un espacio de trabajo unificado. | Herramientas de gestión de proyectos completas: planificación, ejecución, paneles de control, cronogramas de Gantt y flujos automatizados. | Tableros Kanban para gestión visual de proyectos, con listas, etiquetas y archivos adjuntos. | Gestión de tareas, seguimiento de tiempo, automatización de flujos y colaboración integrada. |
|  | Precios y Costos | Planes escalables desde versión gratuita para startups en etapas iniciales. | Plan gratuito limitado + planes premium desde $9.80 por usuario/mes. | Plan gratuito limitado + planes premium desde $5 por usuario/mes. | Plan gratuito robusto + planes pagos desde $5 por usuario/mes. |
|  | Canales de distribución (Web y/o Móvil) | SaaS en la nube accesible desde navegador, con integraciones como Slack y Google Workspace. | Distribución vía web oficial, apps móviles y con integraciones (Microsoft Teams, Salesforce). | Distribución vía web oficial y apps móviles (iOS, Android). | Distribución vía web, apps móviles y extensiones para navegador. |
| **Análisis SWOT** | Fortalezas | Innovación en colaboración en tiempo real, enfoque en startups. | Funcionalidad robusta, integraciones empresariales, análisis predictivo. | Interfaz simple e intuitiva, accesibilidad amplia, múltiples integraciones. | Altamente personalizable, buena relación calidad-precio, integración fuerte. |
|  | Debilidades | Base de usuarios inicial limitada. | Curva de aprendizaje pronunciada. | Pocas funciones avanzadas para proyectos complejos. | Puede ser abrumador por tantas funciones. |
|  | Oportunidades | Expansión en mercados emergentes y nuevas tecnologías. | Nuevas funciones de IA y expansión global. | Nuevas integraciones y funciones para equipos grandes. | Crecimiento global, mejoras en automatización e inteligencia artificial. |
|  | Amenazas | Competencia con herramientas más establecidas y necesidad de mantenerse actualizado. | Competencia de herramientas más accesibles y económicas. | Competencia con herramientas más completas al mismo costo. | Competencia con plataformas con base de usuarios fiel. |


#### 2.1.2. Estrategias y tácticas frente a competidores  

Nuestra estrategia se basará en potenciar nuestras fortalezas y capitalizar las debilidades de la competencia, mientras aprovechamos las oportunidades del mercado y mitigamos las amenazas identificadas.

**Fortalezas propias y cómo las aprovecharemos:**

- **Interfaz intuitiva y colaboración en tiempo real:** destacaremos estas características como diferenciadores frente a competidores más complejos como Wrike y ClickUp, posicionándonos como la opción más ágil y accesible para startups tecnológicas.

- **Enfoque en startups:** dirigiremos nuestras campañas de marketing digital hacia comunidades tecnológicas, incubadoras y hubs de innovación, donde nuestro producto puede generar mayor impacto inicial.


**Debilidades de la competencia y tácticas para aprovecharlas:**

- La curva de aprendizaje de Wrike y la complejidad de ClickUp representan una barrera para nuevos usuarios; en contraste, resaltaremos nuestra simplicidad y eficiencia.

- Trello, aunque intuitivo, tiene limitaciones en funciones avanzadas, lo que nos permite diferenciarnos con un sistema que combina facilidad de uso con integraciones relevantes.

**Oportunidades del mercado y acciones concretas:**

- Aprovecharemos el crecimiento de las startups tecnológicas y de los equipos distribuidos, ofreciendo planes escalables y accesibles, desde versiones gratuitas hasta opciones premium.

- Incorporaremos integraciones con herramientas ampliamente utilizadas (Slack, Google Workspace, Microsoft Teams), fortaleciendo la conectividad con el ecosistema digital de nuestros clientes.

- Implementaremos mejoras continuas basadas en retroalimentación, con especial foco en automatización de tareas y en el desarrollo de funcionalidades innovadoras que mantengan vigente nuestra propuesta.

**Amenazas y medidas de mitigación:**

- Frente a la fuerte competencia de plataformas consolidadas, mantendremos precios flexibles y competitivos que atraigan a equipos en crecimiento.

- Para contrarrestar la lealtad de usuarios hacia otras herramientas, nos enfocaremos en ofrecer una experiencia de usuario excepcional y soporte cercano, creando una comunidad que impulse la fidelización.

- Adoptaremos un enfoque proactivo de innovación para mantenernos al día con las tendencias del sector y responder rápidamente a cambios en las demandas del mercado.

Con este enfoque integral, WorkHub podrá diferenciarse en el mercado, consolidar su presencia entre startups y escalar progresivamente hacia segmentos más amplios, garantizando relevancia y competitividad sostenida.

### 2.2. Entrevistas  
#### 2.2.1. Diseño de entrevistas  

**Segmentos encontrados:**

- Líder o Gerente de Empresa (Product Owner y Scrum Master)

- Equipo de Desarrollo de proyectos

Antes de poder realizar las entrevistas, consideramos prudente poder concretar un análisis previo para poder realizar las entrevistas de una mejor manera. Es por ello, que para cada uno de nuestros segmentos proponemos estas preguntas para poder conocer un poco más sobre nuestro público objetivo.

Preguntas :

preguntas ordenadas para entrevistar a los dos segmentos objetivos de la startup **"TASKMASTER"**:

**Segmento: Líder o Gerente de Empresa (Product Owner y Scrum Master)**

**Principales:**

1. **Introducción al Rol**: ¿Podría describir su rol en la empresa y las principales responsabilidades que tiene en el área e?

2. **Contexto Empresarial**: ¿Cuál es el enfoque principal de su empresa en términos de productos o servicios de software?

3. **Crecimiento y Desafíos**: ¿Cuáles son los mayores desafíos que enfrenta su empresa actualmente en términos de crecimiento y gestión de proyectos?

4. **Experiencias Pasadas**: ¿Ha tenido alguna experiencia negativa con las herramientas actuales de gestión de proyectos que utiliza?

5. **Necesidades Específicas**: ¿Qué características considera esenciales en una herramienta de gestión de proyectos para apoyar el crecimiento y la eficiencia de su equipo?

6. **Colaboración y Comunicación**: ¿Cómo maneja actualmente la colaboración y la comunicación entre los diferentes equipos dentro de su empresa?

7. **Evaluación de Soluciones Actuales**: ¿Siente que las herramientas actuales limitan su capacidad para innovar y liderar en su sector?

8. **Visión Futura**: ¿Cómo imagina la evolución de sus procesos de gestión de proyectos en los próximos 5 años?

9. **Interés en Nuevas Soluciones**: ¿Qué tan abierto estaría a explorar y adoptar una nueva herramienta de gestión de proyectos que ofrezca características avanzadas y personalizables?

10. **Experiencia con Proveedores Externos**: ¿Cuál ha sido su experiencia al trabajar con proveedores externos de soluciones de software? ¿Qué busca en un socio estratégico?

11. **Expectativas a Largo Plazo**: ¿Qué expectativas tendría para una colaboración a largo plazo con una empresa que ofrezca soluciones de gestión de proyectos?

12. **Adaptabilidad y Personalización**: ¿Qué tan importante es para usted que una herramienta de gestión se adapte específicamente a las necesidades y procesos de su empresa?

13. **Consideraciones de Seguridad**: ¿Qué preocupaciones o requisitos de seguridad tiene al implementar nuevas herramientas de software?

14. **Disposición a Colaborar**: Si encuentra que una herramienta cumple con sus expectativas, ¿estaría dispuesto a colaborar con la empresa desarrolladora para ajustar la herramienta a las necesidades emergentes de su equipo?

**Complementarias:**

1. **Integración con Herramientas Existentes**: ¿Qué tan importante es para usted que la nueva herramienta de gestión de proyectos se integre sin problemas con las herramientas de software que ya utiliza su equipo?

2. **Medición del Éxito del Proyecto**: ¿Cuáles son los indicadores clave que utiliza para medir el éxito de un proyecto? ¿Cómo una nueva herramienta podría ayudar a mejorar estos indicadores?

3. **Gestión de Riesgos**: ¿Cómo maneja actualmente los riesgos en los proyectos de desarrollo de software? ¿Qué características le gustaría ver en una herramienta de gestión para facilitar este proceso?

4. **Personalización de Flujos de Trabajo**: ¿Qué tan crucial es para usted la capacidad de personalizar los flujos de trabajo dentro de una herramienta de gestión de proyectos?

5. **Soporte y Actualizaciones**: ¿Qué expectativas tiene respecto al soporte técnico y la frecuencia de actualizaciones de una herramienta de gestión de proyectos?

**Segmento: Equipo de Desarrollo de proyectos**

**Principales:**

1. **Introducción al Rol**: ¿Podría compartirnos un poco sobre su rol en el equipo de desarrollo y las tareas diarias que realiza?

2. **Contexto del Equipo**: ¿Cómo describiría la estructura de su equipo y el tipo de proyectos en los que trabajan habitualmente?

3. **Desafíos en el Desarrollo**: ¿Cuáles son los principales desafíos que enfrenta su equipo en la gestión del flujo de trabajo y la colaboración?

4. **Experiencias Pasadas**: ¿Han tenido alguna experiencia negativa con las herramientas actuales que utilizan para la gestión de proyectos?

5. **Necesidades Específicas**: ¿Qué funcionalidades cree que le facilitarían a su equipo la colaboración y la gestión del trabajo diario?

6. **Impacto en la Productividad**: ¿Cómo afecta la falta de herramientas adecuadas en la eficiencia y productividad del equipo?

7. **Visibilidad y Supervisión**: ¿Qué tan importante es para su equipo tener visibilidad sobre el progreso de los proyectos y el trabajo de cada miembro?

8. **Satisfacción con Soluciones Actuales**: ¿Sienten que las herramientas actuales limitan su capacidad de entregar proyectos de alta calidad en tiempo y forma?

9. **Visión Futura**: ¿Cómo imagina que podrían mejorar los procesos de desarrollo con una herramienta que optimice la gestión y la colaboración?

10. **Evaluación de Nuevas Soluciones**: ¿Qué factores considera cruciales al evaluar una nueva herramienta de gestión para su equipo?

11. **Experiencia con Proveedores Externos**: ¿Han trabajado anteriormente con proveedores de herramientas de software? ¿Cómo fue esa experiencia?

12. **Expectativas a Largo Plazo**: ¿Qué espera de una colaboración a largo plazo con un proveedor de soluciones de gestión de proyectos?

13. **Personalización y Flexibilidad**: ¿Qué tan importante es para su equipo que una herramienta de gestión sea flexible y personalizable según sus necesidades?

14. **Disposición a Adoptar Nuevas Herramientas**: Si una nueva herramienta satisface las necesidades del equipo, ¿estaría dispuesto a adoptarla y colaborar con la empresa desarrolladora para su mejora continua?

**Complementarias:**

1. **Interfaz de Usuario**: ¿Qué tan importante es para usted que la interfaz de la herramienta de gestión sea intuitiva y fácil de usar? ¿Cómo influiría esto en la adopción por parte del equipo?

2. **Colaboración entre Equipos**: ¿Cómo podría una nueva herramienta de gestión mejorar la colaboración no solo dentro de su equipo, sino también con otros departamentos de la empresa?

3. **Manejo de Prioridades**: ¿Cómo maneja actualmente su equipo las prioridades de tareas y proyectos? ¿Qué funcionalidades en una herramienta de gestión podrían facilitar este proceso?

4. **Capacitación y Adaptación**: ¿Qué tan fácil o difícil le resulta a su equipo adaptarse a nuevas herramientas? ¿Qué tipo de soporte o capacitación considera necesario para una transición exitosa?

5. **Retroalimentación Continua**: ¿Cómo se maneja actualmente la retroalimentación dentro del equipo? ¿Qué tan útil sería una herramienta que facilite la retroalimentación continua sobre el progreso y la calidad del trabajo?

#### 2.2.2. Registro de entrevistas  


**Segmento 1:** **Líder o Gerente de Empresa (Product Owner y Scrum Master)**

| **ENTREVISTA 1** | |
|------------------|----------------------------|
| **Nombre entrevistado** |  Juan de la Cruz  |
| **Edad** | 25 |
| **Profesión** | Ingeniero de Software |
| **Departamento** | Lima  |
| **Inicio del video** | 0:08 |
| **Fin del video** | 8:30 |
| **Link del video** | https://goo.su/SUO1 |
| **Foto entrevista** | ![Texto alternativo](Assets/TB1/entrevista1.png) |
| **Resumen** | La entrevista con Juan de la Cruz, lidel del Grupo JPSP, reveló aspectos clave sobre la gestión de proyectos y el impacto de las herramientas que existen actualmente. El destacó que su principal responsabilidad es supervisar al equipo de desarrollo para cumplir con los plazos y estándares de calidad, mientras maneja el crecimiento rápido y los desafíos de integración tecnológica. Aunque también menciono que ha tenido experiencias mixtas con las herramientas actuales, principalmente debido a problemas de integración y personalización, considera esencial que las nuevas soluciones ofrezcan flexibilidad, integración fluida y capacidades avanzadas. La incorporación de tecnologías emergentes es vista como crucial para mejorar la eficiencia y la toma de decisiones. Además, se busca una solución que facilite la colaboración y la comunicación centralizada, y que esté dispuesta a adaptarse a las necesidades cambiantes del equipo. El entrevistado enfatiza la importancia de la seguridad y prioriza a los proveedores que brindan soporte confiable y pueden adaptar sus soluciones a los requisitos individuales. En el futuro, se espera una evolución hacia mayor automatización y herramientas que se adapten rápidamente a los cambios en los proyectos. |

| **ENTREVISTA 2** | |
|------------------|----------------------------|
| **Nombre entrevistado** | Carlos Medina Domingues |
| **Edad** | 54 |
| **Profesión** | Ingeniero de Sistemas  |
| **Departamento** | Lima |
| **Inicio del video** | 8:31 |
| **Fin del video** | 23:14 |
| **Link del video** | https://goo.su/SUO1 |
| **Foto entrevista** | ![ImagenEntrevista](Assets/TB1/Imagen_Entrevista2.PNG) |
| **Resumen** | Durante la entrevista, Carlos, gerente de desarrollo de aplicaciones y servicios en Atentus, explicó que trabaja principalmente de forma remota, coordinando equipos con empleados en distintas partes del mundo. Para la gestión utiliza metodologías ágiles como Agile y Scrum, junto con herramientas como Jira para organizar sprints y el product backlog. Destacó que una de sus principales necesidades es que las herramientas de gestión puedan integrarse con sistemas ya existentes, ya que ninguna empresa empieza desde cero y resulta esencial migrar progresivamente sin afectar la operatividad. También recalcó la importancia de que estas herramientas sean capaces de adaptarse a los horarios y dinámicas de trabajo de un equipo global, pues la coordinación en contextos remotos es clave. Finalmente, resaltó que, en un mercado altamente competitivo, es necesario innovar constantemente, y afirmó estar abierto a probar nuevas soluciones siempre que aporten valor y se ajusten a las necesidades reales de la empresa. |

| **ENTREVISTA 3** | |
|------------------|----------------------------|
| **Nombre entrevistado** | Alejandro David Bejarano Medina |
| **Edad** | 55 |
| **Profesión** | Ingeniero Electrico  |
| **Departamento** | Lima |
| **Inicio del video** | 23:15 |
| **Fin del video** | 30:57 |
| **Link del video** | https://goo.su/SUO1 |
| **Foto entrevista** | ![ddd](Assets/TB1/alejandrobejarano) |
| **Resumen** | El entrevistado, líder de empresa orientada principalmente a las ventas y servicios, destacó que actualmente enfrentan limitaciones al gestionar sus procesos de forma manual con herramientas básicas como Office, lo que retrasa la eficiencia y dificulta la innovación. Entre los principales desafíos mencionó la competencia en un mercado en crecimiento y la necesidad de optimizar la gestión de proyectos y servicios. Considera esencial contar con un sistema integral que abarque tanto la parte administrativa como todo el ciclo de servicios, con características avanzadas, personalizables y seguras, que restrinjan accesos indebidos. Además, valora la integración con herramientas existentes, la colaboración fluida entre equipos y el cumplimiento de plazos de entrega por parte de socios estratégicos. Ve la adopción de una nueva herramienta como clave para un cambio total en los próximos años, permitiendo un mejor control en tiempo real de actividades, inversiones y logística, lo cual impactaría directamente en la competitividad y crecimiento de la empresa. |

| **Duración total de las entrevistas** | 30:57  |
|---------------------------------------|---|
| **Link general del video**            | https://goo.su/SUO1  |



**Segmento 2: Equipo de Desarrollo de proyectos**

| **ENTREVISTA 1** |  |
|------------------|----------------------------|
| **Nombre entrevistado** | Eric Espinoza Perez |
| **Edad** | 24 |
| **Profesión** | Ingeniero de Sistemas |
| **Departamento** | Lima |
| **Inicio del video** |  31:00|
| **Fin del video** | 38:17 |
| **Link del video** | https://goo.su/SUO1 |
| **Foto entrevista** | ![ddd](Assets/TB1/eric_1.png) |
| **Resumen** | El entrevistado, de 24 años y parte de un equipo de desarrollo de proyectos multidisciplinario en psicología, señaló que su rol se centra en analizar necesidades, coordinar entregables y apoyar la organización del flujo de trabajo. Su equipo trabaja en proyectos digitales con participación de desarrolladores, diseñadores y administradores, pero enfrenta dificultades en la gestión debido a la dispersión de información entre múltiples canales (correos, chats, hojas de cálculo), lo que provoca retrasos, duplicidad de esfuerzos y una menor eficiencia en la colaboración. Además, mencionó experiencias negativas con herramientas poco intuitivas y rígidas, que limitan la capacidad de cumplir plazos con calidad. En cuanto a necesidades, destacó la importancia de contar con una plataforma centralizada que integre tableros visuales, calendarios compartidos, notificaciones claras. |

| **ENTREVISTA 2** | |
|------------------|----------------------------|
| **Nombre entrevistado** | Jhon Chuchon |
| **Edad** | 22 |
| **Profesión** | Ingeniero de Software |
| **Departamento** | Lima |
| **Inicio del video** | 38:18 |
| **Fin del video** | 48:47  |
| **Link del video** | https://goo.su/SUO1 |
| **Foto entrevista** | ![ddd](Assets/TB1/Entrevista5.png) |
| **Resumen** | El entrevistado forma parte de un equipo de desarrollo de proyectos, donde apoya en la programación de módulos y pruebas de nuevas funcionalidades. Su equipo está conformado por programadores juniors y seniors, diseñadores UX, QA testers y analistas de requerimientos, trabajando bajo metodologías ágiles. Entre los principales desafíos mencionó la comunicación, ya que al trabajar de forma remota no siempre están conectados al mismo tiempo, así como los cambios repentinos de prioridades que generan desorden al pausar tareas en curso. Sobre herramientas anteriores como Trello, Slack, Excel y Drive, señaló que fueron un dolor de cabeza porque la información estaba dispersa y en ocasiones se duplicaban tareas por falta de claridad. Considera que sería de gran ayuda contar con una plataforma unificada que les permita ahorrar tiempo, ser más eficientes, automatizar procesos con alertas, y que además sea fácil de aprender, rápida, ligera e integrable con aplicaciones externas. |

| **ENTREVISTA 3** | |
|------------------|----------------------------|
| **Nombre entrevistado** | Andres Santos Espinoza |
| **Edad** | 20 |
| **Profesión** | Ingeniero de Software |
| **Departamento** | Lima |
| **Inicio del video** | 48:48 |
| **Fin del video** | 55:22 |
| **Link del video** | https://goo.su/SUO1 |
| **Foto entrevista** | ![ddd](Assets/TB1/andresentrevista.jpg) |
| **Resumen** |El entrevistado, miembro de un equipo multidisciplinario de desarrollo de proyectos digitales, desempeña tareas de programación, pruebas, análisis y coordinación del flujo de trabajo. Señaló que los principales desafíos son la comunicación remota y los cambios repentinos de prioridades, lo que genera desorden y retrasos. Su experiencia con herramientas como Trello, Slack, Excel y Drive fue negativa por la dispersión de información y duplicidad de tareas. Considera clave contar con una plataforma unificada, intuitiva, ligera y flexible, que integre tableros visuales, calendarios, notificaciones claras y automatización con alertas. Resaltó que la falta de herramientas adecuadas disminuye la productividad y limita la calidad de las entregas, mientras que una solución optimizada mejoraría la eficiencia, la visibilidad del progreso y la colaboración entre áreas, siempre que sea fácil de adoptar y permita personalización y soporte continuo.  |

| **Duración total de las entrevistas** | 55:22  |
|---------------------------------------|---|
| **Link general del video**            | https://goo.su/SUO1  |



#### 2.2.3. Análisis de entrevistas  

**Análisis Segmento 1:** **Líder o Gerente de Empresa (Product Owner y Scrum Master)**

Las entrevistas con líderes de empresas destacan una urgente necesidad de modernizar las herramientas de gestión de proyectos. Un 75% de los entrevistados enfatiza la importancia de integrar tecnologías emergentes, mientras que 85% considera que estas herramientas deben ser intuitivas y adaptables a diversos dispositivos.

La mayoría de los líderes, aproximadamente 67%, ha tenido experiencias mixtas con las soluciones actuales, citando problemas de integración y personalización. La flexibilidad y una buena relación costo-beneficio son cruciales, con un 70% de los encuestados indicando que las nuevas soluciones deben adaptarse a las necesidades del equipo. Además, la seguridad de los datos es prioritaria para el 80%, quienes buscan proveedores confiables.

Los líderes están enfocados en encontrar herramientas modernas que no solo mejoren la eficiencia y la colaboración, sino que también respondan a las cambiantes demandas de los proyectos. La integración de la IA y la personalización de las herramientas son vistas como esenciales para el éxito futuro en sus organizaciones.

**Análisis Segmento 2: Equipo de Desarrollo de proyectos**

Las entrevistas con integrantes de equipos de desarrollo de proyectos revelan desafíos significativos con las herramientas de gestión actuales. Un 78% menciona la falta de flexibilidad y adaptabilidad, lo que limita la colaboración y la eficiencia. Estas herramientas son a menudo percibidas como poco intuitivas y difíciles de personalizar. Los entrevistados coinciden en que es crucial contar con herramientas innovadoras con una interfaz de usuario mejorada y seguimiento constante del progreso. Un 70% sostiene que las soluciones ideales deben ser precisas y adaptables a distintos modelos de negocio. Fabricio destaca que la falta de herramientas innovadoras afecta la colaboración. Agustín señala que herramientas como GitHub son poco intuitivas y que la comunicación podría mejorar con mejores programas de gestión. Rodrigo menciona que la falta de seguimiento y flexibilidad ralentiza el trabajo y espera que futuras herramientas integren tecnologías emergentes. En resumen, los equipos de desarrollo buscan soluciones que mejoren la eficiencia y la colaboración, priorizando la adaptabilidad y la facilidad de uso.

### 2.3. Needfinding  
#### 2.3.1. User Personas

A continuación, se presentan las User Personas que representan a nuestros dos segmentos principales.

**Semento 1: Líderes de projecto:**

![ddd](Assets/TB1/SunoQuispeHuaman.png)

**Semento 2: Equipo de Desarrollo de Proyectos:**

![ddd](Assets/TB1/DiegoRamírezTejeda.png)

#### 2.3.2. User Task Matrix  

**Semento 1: Líderes de projecto:**

<table>
  <thead>
    <tr>
      <th>Actividades</th>
      <th colspan="2">Suno Quispe Huaman</th>
    </tr>
    <tr>
      <th></th>
      <th>Frecuencia</th>
      <th>Importancia</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Supervisar avance de proyectos en tiempo real</td>
      <td>Diario</td>
      <td>Alta</td>
    </tr>
    <tr>
      <td>Asignar tareas y definir roles</td>
      <td>Diario/Semanal</td>
      <td>Alta</td>
    </tr>
    <tr>
      <td>Revisar reportes financieros (presupuestos, pagos básicos)</td>
      <td>Semanal</td>
      <td>Alta</td>
    </tr>
    <tr>
      <td>Coordinar comunicación entre áreas y equipos</td>
      <td>Diario</td>
      <td>Alta</td>
    </tr>
    <tr>
      <td>Generar reportes de progreso para la dirección</td>
      <td>Semanal/Mensual</td>
      <td>Alta</td>
    </tr>
    <tr>
      <td>Personalizar flujos de trabajo según el proyecto</td>
      <td>Según necesidad</td>
      <td>Media</td>
    </tr>
    <tr>
      <td>Recibir alertas de retrasos o riesgos en proyectos</td>
      <td>Diario</td>
      <td>Alta</td>
    </tr>
    <tr>
      <td>Evaluar desempeño del equipo mediante métricas</td>
      <td>Mensual</td>
      <td>Media</td>
    </tr>
  </tbody>
</table>


**Semento 2: Equipo de Desarrollo de Proyectos:**

<table>
  <thead>
    <tr>
      <th>Actividades</th>
      <th colspan="2">Diego Ramírez Tejeda</th>
    </tr>
    <tr>
      <th></th>
      <th>Frecuencia</th>
      <th>Importancia</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Visualizar tareas asignadas en tableros Kanban</td>
      <td>Diario</td>
      <td>Alta</td>
    </tr>
    <tr>
      <td>Registrar avances y actualizar estado de tareas</td>
      <td>Diario</td>
      <td>Alta</td>
    </tr>
    <tr>
      <td>Revisar plazos en calendarios compartidos</td>
      <td>Diario/Semanal</td>
      <td>Alta</td>
    </tr>
    <tr>
      <td>Colaborar con otros miembros mediante comentarios/chat</td>
      <td>Diario</td>
      <td>Alta</td>
    </tr>
    <tr>
      <td>Recibir notificaciones de cambios en prioridades</td>
      <td>Diario</td>
      <td>Alta</td>
    </tr>
    <tr>
      <td>Gestionar prioridades personales de trabajo</td>
      <td>Diario/Semanal</td>
      <td>Alta</td>
    </tr>
    <tr>
      <td>Revisar entregables del equipo para asegurar calidad</td>
      <td>Semanal</td>
      <td>Media</td>
    </tr>
    <tr>
      <td>Adaptarse a nuevas herramientas o procesos internos</td>
      <td>Según necesidad</td>
      <td>Media</td>
    </tr>
    <tr>
      <td>Acceder a tutoriales o soporte técnico de la herramienta</td>
      <td>Según necesidad</td>
      <td>Media</td>
    </tr>
  </tbody>
</table>


#### 2.3.3. User Journey Mapping  

**Semento 1: Líderes de projecto:**

![ddd](Assets/TB1/userjourneymap1.jpg)

**Semento 2: Equipo de Desarrollo de Proyectos:**

![ddd](Assets/TB1/userjourneymap2.jpg)

#### 2.3.4. Empathy Mapping
El Empathy Map nos permite identificar las emociones, pensamientos y acciones de nuestros usuarios, para comprender mejor sus necesidades y motivaciones. Con este propósito, se elaboraron los siguientes cuadros para los segmentos objetivo definidos:


**Semento 1: Líderes de projecto:**
<br>
<br>

![ddd](Assets/TB1/EmpathymapSegmento1.png)

<br>
<br>

**Semento 2: Equipo de Desarrollo de Proyectos:**

<br>
<br>

![ddd](Assets/TB1/EmpathymapSegmento2.png)

<br>
<br>

#### 2.3.5 Ubiquitous Language  

En el nuestro proyecto, es fundamental contar con un lenguaje común que nos permita comunicarnos de manera clara y sin ambigüedades. Por ello, hemos definido un Ubiquitous Language, compuesto por términos clave que utilizaremos para describir tareas, roles y procesos. De esta forma, aseguramos que todos los involucrados compartan la misma comprensión y podamos trabajar de manera más organizada y eficiente.

| Término (Inglés)        | Traducción (Español)   | Definición                                                                 |
|--------------------------|------------------------|----------------------------------------------------------------------------|
| Project                 | Proyecto               | Conjunto de actividades planificadas con un objetivo específico, un tiempo definido y recursos asignados. |
| Task                    | Tarea                  | Actividad puntual asignada a un miembro del equipo, con fecha de inicio y vencimiento. |
| Task Board              | Tablero de tareas      | Vista visual tipo Trello que organiza y gestiona las tareas asignadas según su estado (pendiente, en progreso, completada). |
| Kanban Board            | Tablero Kanban         | Herramienta visual que organiza las tareas en columnas según su estado (pendiente, en progreso, completada). |
| Milestone               | Hito                   | Evento clave dentro del proyecto que marca un avance importante o un entregable crítico. |
| Budget                  | Presupuesto            | Estimación financiera destinada a la ejecución de un proyecto, que incluye gastos, pagos y recursos. |
| Expense                 | Gasto                  | Registro de salida de dinero asociada a un proyecto. |
| Team Member             | Miembro de equipo      | Profesional responsable de ejecutar tareas asignadas dentro del proyecto. |
| Team Leader             | Líder de proyecto      | Persona encargada de coordinar al equipo, supervisar el progreso y garantizar el cumplimiento de plazos y recursos. |
| Collaboration           | Colaboración           | Interacción en tiempo real entre los miembros del equipo para avanzar en el desarrollo del proyecto. |
| Progress Tracking       | Seguimiento del progreso | Monitoreo continuo de tareas, métricas y resultados para evaluar el avance del proyecto. |
| Notification            | Notificación           | Mensaje automático que informa a los usuarios sobre actualizaciones, vencimientos o cambios relevantes en el proyecto. |
| Report                  | Reporte                | Documento o visualización que muestra el estado de un proyecto, métricas de desempeño y cumplimiento de objetivos. |
| Project Dashboard       | Tablero del proyecto   | Vista de métricas y estadísticas globales del proyecto, accesible por el Team Leader. |
| Member Dashboard        | Tablero del miembro    | Vista de métricas y estadísticas individuales de los miembros, accesible por el Team Leader. |
| Progress Report         | Reporte de avance      | Documento solicitado por un Team Member que muestra su propio progreso en las tareas asignadas. |
| User List               | Lista de usuarios      | Vista que muestra todos los usuarios que forman parte de un proyecto, incluyendo su rol y estado de participación. |
| Personal Calendar       | Calendario personal    | Vista individual del calendario de un miembro, con sus tareas, fechas límite y hitos asignados. |
| Role                    | Rol                    | Función asignada dentro del proyecto (ejemplo: líder, miembro, supervisor). |
| Deadline                | Fecha límite           | Día y hora máxima en la que debe completarse una tarea o entregable. |
| Workspace               | Espacio de trabajo     | Área digital dentro de la plataforma donde un equipo gestiona sus proyectos y tareas. |
| Sprint                  | Iteración / Sprint     | Periodo corto de trabajo (1-4 semanas) en el que se completan entregables definidos dentro de metodologías ágiles. |
| Backlog                 | Lista de pendientes    | Conjunto priorizado de tareas, historias de usuario o requerimientos que deben desarrollarse en el proyecto. |
| User Story              | Historia de usuario    | Descripción breve y clara de una funcionalidad desde la perspectiva del usuario final. |
| Deliverable             | Entregable             | Resultado tangible o intangible que debe ser completado y entregado en el marco de un proyecto. |
| Dependency              | Dependencia            | Relación entre tareas o actividades en la que una no puede comenzar o finalizar hasta que otra se haya completado. |
| Project Board           | Tablero de proyectos   | Vista que muestra todos los proyectos en los que participa un usuario, con información resumida como nombre, estado, fecha límite y rol asignado. |


### 2.4. Requirements specification
En esta sección se definen los requisitos del producto digital a partir del análisis de la información obtenida. Se incluyen diferentes herramientas como User Stories, Impact Map y Product Backlog, que permiten organizar y priorizar las necesidades de los usuarios y del negocio.

#### 2.4.1. User Stories

| **EPIC(ID)** | **Título**                              | **Descripción**                                                                                                                                                        |
| ------------ | --------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **EP01**     | **Landing Page**                        | Como visitante, quiero acceder a una página de inicio clara que explique los beneficios de TaskMaster, para evaluar si es adecuado para mis necesidades.               |
| **EP02**     | **Registro y autentificacion de usuario** | Como trabajador, quiero registrarme y verificar mi identidad para acceder a TaskMaster, garantizando que solo personal autorizado pueda acceder a las funcionalidades. |
| **EP03**     | **Gestión de Proyectos y Tareas**       | Como líder de equipo, quiero gestionar proyectos y asignar tareas a los miembros del equipo para distribuir el trabajo de manera organizada.                           |
| **EP05**     | **Notificaciones**                      | Como miembro del equipo, quiero recibir notificaciones sobre tareas asignadas, actualizaciones y fechas límite, para mantenerme informado y priorizar mi trabajo.      |
| **EP06**     | **Visualización y Seguimiento**         | Como miembro del equipo, quiero poder ver el progreso de mis tareas en tiempo real para estar al tanto de mis responsabilidades.                                       |
| **EP07**     | **Analítica y Reportes**                | Como líder de equipo, quiero generar y visualizar reportes de desempeño del equipo para mejorar la productividad y tomar decisiones basadas en datos.                  |
| **EP08**     | **Integraciones Técnicas**              | Como desarrollador, quiero implementar un backend con servicios CRUD (crear, leer, actualizar y eliminar) para proyectos, tareas, usuarios y reportes, de modo que la lógica central de TaskMaster esté estructurada y mantenible  |
| **EP09**     | **Investigación y Validación Técnica**  | Como miembro del equipo de desarrollo, quiero validar la seguridad de TaskMaster mediante pruebas técnicas para garantizar la protección de los datos de los usuarios. |


| Story ID | User      | Priority | Epic | Title                                            | Description                                                                                                                                                               | Acceptance Criteria                                                                                                                                                                                                                                                                                      |
| -------- | --------- | -------- | ---- | ------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| US01     | Visitante | High     | EP01 | Información general sobre TaskMaster             | Como visitante, quiero entender rápidamente los beneficios y características de TaskMaster, para evaluar si se ajusta a mis necesidades.                                  | Escenario: Dado que el visitante accede a la página principal, cuando hace scroll hasta la sección Características clave, entonces el sistema muestra una lista visual destacada con las funciones principales de la aplicación.                                                                         |
| US02     | Visitante | High     | EP01 | Llamado a la acción para descargar la aplicación | Como visitante, quiero tener un botón de registro claro y accesible para descargar la aplicación.                                                                         | Escenario: Dado que un visitante accede a la landing page, cuando visualiza el botón de registro en la parte superior o en el pie de página y hace clic en él, entonces el sistema lo redirige a la app store.                                                                                           |
| US03     | Visitante | Medium   | EP01 | Testimonios de usuarios                          | Como visitante, quiero ver testimonios de usuarios reales de TaskMaster para confiar en su efectividad.                                                                   | Escenario: Dado que el visitante está en la página de inicio, cuando baja hasta la sección de testimonios, el sistema debe mostrar testimonios con texto y fotos de usuarios que han tenido éxito con la app.                                                                                            |
| US04     | Visitante | Medium   | EP01 | Muestra de planes y precios                      | Como visitante, quiero ver las opciones de planes y precios de TaskMaster para poder elegir el más adecuado.                                                              | Escenario: Dado que el visitante accede a la página principal, cuando navega hasta la sección de planes de suscripción, entonces el sistema muestra los distintos planes con sus características y un botón de comparar.                                                                                 |
| US05     | Visitante | Low      | EP01 | Adaptabilidad móvil                              | Como usuario móvil, quiero navegar la landing page sin problemas, para acceder a la información desde cualquier dispositivo.                                              | Escenario 1: Dado que el usuario accede desde el móvil, cuando hace clic en el ícono de menú, entonces se despliegan las opciones principales y el fondo se oscurece para mejor contraste.                                                                                                               |
| US06     | Visitante | Low      | EP01 | Navegación mediante Encabezado                   | Como usuario, quiero un menú de navegación claro en el encabezado, para acceder fácilmente a las diferentes secciones de la página.                                       | Escenario 1: Acceso a secciones desde el encabezado. Dado que un visitante explora la plataforma informativa cuando utiliza las opciones de navegación en el encabezado entonces puede desplazarse a las diferentes secciones informativas. El encabezado permanece accesible durante el desplazamiento. |
| US07     | Visitante | Medium   | EP01 | Misión y visión                                  | Como visitante interesado, quiero conocer la visión y misión de la empresa, para entender sus objetivos a largo plazo y su proyección de futuro.                          | Escenario 1: Visibilidad de la declaración de visión. Dado que un visitante navega por la sección sobre la empresa, cuando busca información sobre las metas futuras y actuales de la empresa entonces debe encontrar claramente destacada la declaración de visión y misión.                            |
| US08     | Visitante | High     | EP01 | About the team                                   | Como visitante quiero acceder a la sección About the Team para conocer quiénes son los integrantes y su rol en el proyecto.                                               | Dado que el visitante accede a la landing page, cuando hace scroll o selecciona el enlace "About the Team", entonces el sistema muestra la sección con nombres, fotos, roles y una breve descripción de cada integrante.                                                                                 |
| US09     | Visitante | Low      | EP01 | Pie de página                                    | Como visitante quiero visualizar un pie de página con enlaces a secciones clave para encontrar fácilmente información adicional y mantenerme conectado con la plataforma. | Dado que el visitante llega al final de la landing page, cuando visualiza el pie de página, entonces el sistema muestra enlaces a Contacto, Políticas, Términos y redes sociales, y al hacer clic en cada enlace redirige a la sección o recurso correspondiente.                                        |
| US10     | Visitante                 | High     | EP02 | Registro de usuario        | Como visitante quiero registrarme en la plataforma proporcionando mis datos básicos para crear una cuenta y acceder a las funcionalidades de TaskMaster. | Escenario 1: Dado que un visitante proporciona datos válidos, cuando completa el registro, entonces el sistema crea una nueva cuenta y permite el acceso. <br> Escenario 2: Dado que un visitante intenta registrarse con un correo ya existente, cuando completa el registro, entonces el sistema rechaza la acción e informa que el correo ya está en uso.                                           |
| US11     | Team Member / Team Leader | High     | EP02 | Inicio de sesión           | Como usuario registrado quiero autenticarme con mis credenciales para acceder a mi cuenta y gestionar mis proyectos.                                     | Escenario 1: Dado que un usuario proporciona credenciales válidas, cuando solicita autenticación, entonces el sistema valida los datos y concede acceso. <br> Escenario 2: Dado que un usuario proporciona credenciales inválidas, cuando solicita autenticación, entonces el sistema rechaza la acción e informa que los datos no son correctos.                                                      |
| US12     | Team Member / Team Leader | Medium   | EP02 | Recuperación de contraseña | Como usuario registrado quiero restablecer mi contraseña en caso de olvido para poder acceder nuevamente a la plataforma.                                | Escenario 1: Dado que un usuario solicita restablecer su contraseña con un correo válido, cuando el sistema verifica que está registrado, entonces envía un método de recuperación. <br> Escenario 2: Dado que un usuario solicita restablecer su contraseña con un correo no registrado, cuando el sistema valida la información, entonces rechaza la acción e informa que no existe cuenta asociada. |
| US13     | Team Member / Team Leader | Low      | EP02 | Cierre de sesión           | Como usuario registrado quiero finalizar mi sesión para garantizar la seguridad de mi cuenta en cualquier dispositivo.                                   | Escenario 1: Dado que un usuario tiene una sesión activa, cuando solicita cerrarla, entonces el sistema invalida las credenciales y finaliza la sesión. <br> Escenario 2: Dado que un usuario no tiene una sesión activa, cuando solicita cerrar sesión, entonces el sistema rechaza la acción e informa que no hay sesión activa.                                                                     |
| US14     | Team Leader| High     | EP02 | Invitación de usuarios con código de acceso       | Como Team Leader, quiero invitar a los usuarios a través de un código de acceso para que se registren y luego puedan ser asignados a tareas dentro de los proyectos, asegurando que solo los usuarios autorizados puedan colaborar. | **Escenario 1**: Dado que el Team Leader genera un código de acceso único, cuando el usuario recibe el código e ingresa a la plataforma, entonces el sistema permite que el usuario se registre y se una al proyecto. <br> **Escenario 2**: Dado que el usuario se ha unido al proyecto mediante el código, cuando el Team Leader desea asignar tareas, entonces solo puede seleccionar a los usuarios que han ingresado con el código para ser asignados a las tareas. <br> **Escenario 3**: Dado que el Team Leader intenta invitar a un usuario mediante un código, cuando el código es inválido o caduca, el sistema notifica que el código no es válido y evita el registro del usuario. |
| US015    | Team Leader | High     | EP03 | Registro de nuevos proyectos            | Como líder de equipo quiero crear un nuevo proyecto para organizar las tareas y asignar responsables de manera estructurada.                         | Escenario 1: Dado que el líder accede a la opción crear proyecto, cuando completa los campos requeridos (nombre, descripción y fechas) y confirma, entonces el sistema guarda el nuevo proyecto y lo muestra en su tablero. <br> Escenario 2: Dado que el líder intenta crear un proyecto sin nombre, cuando hace clic en guardar, entonces el sistema muestra un mensaje de error indicando que el nombre es obligatorio. |
| US016    | Team Leader | High     | EP03 | Asignación de usuarios a proyectos      | Como líder de equipo quiero asignar usuarios a un proyecto para que puedan colaborar en sus tareas y actividades.                                    | Escenario 1: Dado que el administrador abre la opción asignar usuarios, cuando selecciona varios usuarios y guarda, entonces el sistema asigna a esos usuarios al proyecto y los notifica. <br> Escenario 2: Dado que el administrador intenta asignar un usuario ya agregado, cuando guarda los cambios, entonces el sistema evita duplicados y mantiene la lista correcta.                                               |
| US017    | Team Leader | High     | EP03 | Asignar Tareas para los usuarios        | Como líder de equipo quiero asignar tareas específicas a los miembros para distribuir la carga de trabajo de forma clara.                            | Escenario 1: Dado que el líder selecciona una tarea, cuando asigna un usuario responsable y guarda, entonces el sistema registra la asignación y muestra el nombre del responsable en el tablero. <br> Escenario 2: Dado que el líder intenta asignar una tarea a un usuario inexistente, cuando confirma la acción, entonces el sistema muestra un mensaje de error y no guarda la asignación.                            |
| US018    | Team Leader | Medium   | EP03 | Establecer prioridad de tareas          | Como líder de equipo, quiero asignar prioridades a las tareas dentro de un proyecto para garantizar que las tareas más importantes se hagan primero. | Escenario: Dado que el usuario agrega una nueva tarea, cuando selecciona una prioridad entre alta, media o baja, entonces el sistema ordena las tareas en el tablero según su nivel de prioridad.                                                                                                                                                                                                                          |
| US019    | Team Member | High     | EP03 | Notificaciones de tareas asignadas      | Como miembro del equipo, quiero recibir una notificación cuando se me asigna una nueva tarea, para estar al tanto de mis responsabilidades.          | Escenario: Dado que el administrador asigna una tarea a un miembro del equipo, cuando la asignación se confirma, entonces el sistema envía una notificación en la aplicación y un correo electrónico al miembro correspondiente.                                                                                                                                                                                           |
| US020    | Team Leader | Medium   | EP03 | Modificación de fechas límite de tareas | Como líder de equipo quiero modificar la fecha límite de las tareas para ajustar los plazos según las necesidades del proyecto.                      | Escenario 1: Dado que el líder de equipo accede a una tarea existente, cuando modifica la fecha límite y guarda los cambios, entonces el sistema actualiza la fecha y notifica al usuario asignado. <br> Escenario 2: Dado que el líder intenta establecer una fecha límite anterior a la fecha actual, cuando confirma el cambio, entonces el sistema muestra un mensaje de error indicando que la fecha no es válida.    |
| US021    | Team Member | Medium   | EP03 | Modificación de la prioridad de tareas  | Como miembro del equipo quiero modificar la prioridad de una tarea para organizar mejor el trabajo según su urgencia e importancia.                  | Escenario 1: Dado que el usuario accede a la configuración de una tarea, cuando cambia la prioridad a alta, media o baja, entonces el sistema actualiza la prioridad y reordena las tareas en el tablero según este criterio. <br> Escenario 2: Dado que el usuario intenta guardar una tarea sin seleccionar prioridad, cuando confirma la acción, entonces el sistema asigna por defecto la prioridad “media”.           |
| US022    | Team Member | Medium   | EP03 | Actualización de estado de tareas       | Como miembro del equipo quiero actualizar el estado de una tarea a completada o pendiente para reflejar con precisión su progreso.                   | Escenario 1: Dado que un miembro del equipo accede a una tarea asignada, cuando marca la tarea como completada, entonces el sistema cambia su estado a “Completada” y lo refleja en el tablero. <br> Escenario 2: Dado que un miembro del equipo accede a una tarea, cuando la desmarca como completada, entonces el sistema cambia su estado a “Pendiente” y lo refleja en el tablero.                                    |
| US023    | Team Member | High     | EP04 | Ver progreso de tareas en tiempo real | Como miembro del equipo, quiero ver el progreso de las tareas asignadas en tiempo real para tener una visión clara del estado de los proyectos. | Escenario 1: Dado que el usuario accede al tablero de tareas, cuando consulta las tareas listadas, entonces el sistema muestra indicadores de estado (Pendiente, En progreso, Completada) y actualiza los avances de forma automática. <br> Escenario 2: Dado que un miembro del equipo cambia el estado de una tarea (por ejemplo, de "En progreso" a "Completada"), entonces el sistema actualiza el progreso en tiempo real para reflejar el cambio.     |
| US024    | Team Leader | High     | EP04 | Ver métricas de rendimiento           | Como líder de equipo, quiero ver métricas de rendimiento de cada tarea y miembro para evaluar el progreso y la productividad.                   | Escenario 1: Dado que el gerente de proyectos accede a la sección de métricas, cuando solicita un reporte de desempeño, entonces el sistema genera un gráfico o reporte con tareas completadas, retrasadas y porcentaje de avance de cada miembro y proyecto. <br> Escenario 2: Dado que el líder de equipo selecciona un periodo específico (por ejemplo, mensual), entonces el sistema genera métricas de rendimiento solo para ese período seleccionado. |
| US025    | Team Member | Medium   | EP04 | Visualizar calendario de tareas       | Como miembro del equipo, quiero ver un calendario con mis tareas y sus fechas límite, para organizar mejor mis entregas.                        | Escenario 1: Dado que un miembro tiene tareas con fechas límite, cuando consulta el calendario del proyecto, entonces el sistema muestra las tareas distribuidas según sus plazos. <br> Escenario 2: Dado que el miembro del equipo consulta el calendario, cuando pasa el ratón sobre una tarea, entonces el sistema muestra un resumen rápido de la tarea, incluyendo su nombre y fecha límite.                                                                      |
| US026    | Team Leader | High     | EP05 | Generar reporte de desempeño por miembro | Como líder de equipo, quiero generar un reporte de desempeño por cada miembro de equipo para identificar áreas de mejora.                     | **Escenario 1**: El usuario selecciona "Generar reporte de desempeño" y el sistema debe permitir visualizar las métricas de cada miembro, como tareas completadas, en progreso y retrasadas. <br> **Escenario 2**: Dado que el líder solicita el reporte de desempeño, cuando el reporte se genera, entonces el sistema permite exportarlo en formato PDF o Excel.                                                            |
| US027    | Team Leader | High     | EP05 | Reporte de tareas cumplidas y retrasadas | Como líder de equipo, quiero recibir un reporte de tareas cumplidas y retrasadas para saber qué aspectos del proyecto necesitan más atención. | **Escenario 1**: El sistema debe generar un reporte con un desglose de tareas cumplidas y retrasadas. <br> **Escenario 2**: El sistema debe permitir exportar el reporte en formato PDF o Excel para su distribución.                                                                                                                                                                                                         |
| US028    | Team Member | Medium   | EP05 | Visualizar resumen semanal de avances    | Como miembro del equipo, quiero ver un resumen semanal de mis avances para tener claridad sobre mi progreso en las tareas.                    | **Escenario 1**: Dado que el usuario accede a la sección de reportes, cuando selecciona "Resumen semanal", entonces el sistema muestra un reporte con el número de tareas completadas, en progreso y pendientes durante la última semana. <br> **Escenario 2**: Dado que el usuario selecciona un periodo específico (por ejemplo, de lunes a viernes), entonces el sistema ajusta el reporte según las fechas seleccionadas. |
| US29     | Team Member | High     | EP06 | Notificación de tarea asignada            | Como miembro del equipo, quiero recibir una notificación cuando se me asigne una nueva tarea para estar al tanto de mis responsabilidades.                                    | **Escenario 1**: Dado que un Team Leader asigna una nueva tarea, cuando la asignación se confirma, el sistema envía una notificación en la app y por correo electrónico al miembro. <br> **Escenario 2**: Dado que un Team Leader asigna una tarea, cuando revisa la bandeja de notificaciones, entonces el sistema muestra la tarea asignada y el nombre del miembro asignado.                                              |
| US30     | Team Member | High     | EP06 | Notificación de fecha límite cercana      | Como miembro del equipo, quiero recibir una notificación cuando la fecha límite de una tarea esté cerca para poder priorizarla.                                               | **Escenario 1**: Dado que una tarea tiene una fecha límite próxima, cuando la fecha límite se acerque a 24 horas, el sistema envía una notificación en la app y por correo. <br> **Escenario 2**: Dado que una tarea está cerca de su fecha límite, cuando el Team Leader ingresa al tablero de tareas, el sistema resalta las tareas cercanas a la fecha límite y envía una notificación.                                   |
| US31     | Team Leader | High     | EP06 | Notificación de tarea completada          | Como líder de equipo, quiero recibir una notificación cuando un miembro complete una tarea asignada para hacer un seguimiento del progreso.                                   | **Escenario 1**: Dado que un Team Member marca una tarea como completada, el sistema envía una notificación en la app y por correo electrónico al líder de equipo. <br> **Escenario 2**: Dado que un Team Member ha completado una tarea, cuando ingresa al tablero, el sistema marca la tarea como completada y envía una notificación de progreso.                                                                         |
| US32     | Team Member | Medium   | EP06 | Notificación de nuevo mensaje en proyecto | Como miembro del equipo, quiero recibir notificaciones cuando se agregue un nuevo mensaje en un proyecto para mantenerme actualizado.                                         | **Escenario 1**: Dado que un mensaje es agregado en el proyecto, cuando el Team Leader o otro miembro envía el mensaje, el sistema envía una notificación dentro de la app y por correo electrónico a los miembros. <br> **Escenario 2**: Dado que el Team Leader envía un mensaje, cuando el Team Member ingresa a la plataforma, el sistema marca el mensaje como leído y muestra una notificación de "nuevo mensaje".     |
| US33     | Team Member | Medium   | EP06 | Notificación de actualización de tareas   | Como miembro del equipo, quiero recibir notificaciones cuando se actualice una tarea asignada (como cambio de fecha, prioridad o estado) para estar informado de los cambios. | **Escenario 1**: Dado que el Team Leader actualiza una tarea, cuando el Team Member accede al proyecto, el sistema envía una notificación dentro de la app y por correo electrónico. <br> **Escenario 2**: Dado que el Team Leader actualiza una tarea (por ejemplo, cambia la fecha o la prioridad), cuando el Team Leader revisa el tablero, el sistema resalta las tareas actualizadas y muestra una notificación visual. |
| TS01     | Developer | High     | EP08 | Validación de seguridad en la API                | Como desarrollador, quiero verificar que la API de TaskMaster esté segura para proteger los datos de los usuarios.              | **Escenario**: El equipo de desarrollo realiza pruebas de seguridad para asegurarse de que las credenciales y datos sensibles de los usuarios están correctamente encriptados. |
| TS02     | Developer | High     | EP08 Optimización del rendimiento de la base de datos | Como desarrollador, quiero mejorar el rendimiento de las consultas en la base de datos para que TaskMaster funcione más rápido. | **Escenario**: El sistema realiza pruebas de carga y optimiza las consultas de la base de datos para garantizar tiempos de respuesta más rápidos.                              |
| TS03     | Developer   | Alta     | EP08  | Gestión de Proyectos     | Como desarrollador, quiero implementar la creación, modificación y eliminación de proyectos, para mantener la información organizada y coherente.       | Escenario: Dado que un usuario envía una solicitud válida para crear un proyecto, cuando la API procesa la petición, entonces el sistema registra el nuevo proyecto y lo devuelve en la respuesta.                                                     |
| TS04     | Developer   | Alta     | EP08  | Gestión de Tareas        | Como desarrollador, quiero implementar operaciones para registrar, actualizar estados o prioridades, y eliminar tareas, para reflejar el flujo de trabajo. | Escenario: Dado que un usuario actualiza el estado de una tarea, cuando la API procesa la solicitud, entonces el sistema guarda el cambio y refleja el nuevo estado en la base de datos.                                                                |
| TS05     | Developer   | Media    | EP08  | Administración de Usuarios | Como desarrollador, quiero implementar el manejo de alta, edición y baja de usuarios, para que roles y permisos se mantengan alineados con los proyectos. | Escenario: Dado que un administrador elimina un usuario, cuando la API procesa la solicitud, entonces el sistema desactiva el usuario y asegura que no tenga acceso a futuros proyectos.                                                               |
| TS06     | Developer   | Media    | EP08  | Manejo de Reportes       | Como desarrollador, quiero implementar la generación, actualización y almacenamiento de reportes, para que los líderes accedan a información consistente. | Escenario: Dado que un líder solicita un reporte de desempeño, cuando la API procesa la petición, entonces el sistema genera el documento con métricas actualizadas y lo devuelve en formato descargable (PDF o Excel).                               |
| SS1      | Team Member | High     | EP09 | Integración con herramientas de comunicación | Como miembro del equipo, quiero que TaskMaster se integre con Gmail para recibir actualizaciones sobre mis tareas, para mantenerme al tanto de los cambios importantes sin tener que acceder continuamente a la plataforma. | **Escenario**: El usuario vincula su cuenta de Slack con TaskMaster. Cuando una tarea se asigna o actualiza, el sistema debe enviar una notificación en el canal de Slack correspondiente. |
| SS2      | Team Member | High     | EP09 | Integración con Google Calendar              | Como miembro del equipo, quiero que TaskMaster sincronice mis tareas con Google Calendar para no olvidar mis plazos.                                                                                                        | **Escenario**: El usuario conecta su cuenta de Google Calendar. Las tareas con fechas establecidas se sincronizan automáticamente en su calendario.                                        |

#### 2.4.2. Impact Mapping
Segmento Team leader
![Impact](Assets/TB1/Impact%20map%201.png)
Segmento Team member
![Impact](Assets/TB1/Impact%20map%202.png)

#### 2.4.3. Product Backlog

| Orden | Código US | Título                                               | Story Points |
|-------|-----------|------------------------------------------------------|--------------|
| 1     | US014     | Invitación de usuarios con código de acceso           | 8 |
| 2     | US015     | Registro de nuevos proyectos                          | 8 |
| 3     | US016     | Asignación de usuarios a proyectos                    | 8 |
| 4     | US017     | Asignar Tareas para los usuarios                      | 8 |
| 5     | US019     | Notificaciones de tareas asignadas                    | 8 |
| 6     | US023     | Ver progreso de tareas en tiempo real                 | 8 |
| 7     | US024     | Ver métricas de rendimiento                           | 8 |
| 8     | US026     | Generar reporte de desempeño por miembro              | 8 |
| 9     | US027     | Reporte de tareas cumplidas y retrasadas              | 8 |
| 10    | US029     | Notificación de tarea asignada                        | 8 |
| 11    | US030     | Notificación de fecha límite cercana                  | 8 |
| 12    | US031     | Notificación de tarea completada                      | 8 |
| 13    | TS01      | Validación de seguridad en la API                     | 8 |
| 14    | TS02      | Optimización del rendimiento de la base de datos      | 8 |
| 15    | TS03      | Gestión de Proyectos (implementación en backend)      | 8 |
| 16    | TS04      | Gestión de Tareas (implementación en backend)         | 8 |
| 17    | SS1       | Integración con herramientas de comunicación (Slack)  | 8 |
| 18    | SS2       | Integración con Google Calendar                       | 8 |
| 19    | US010     | Registro de usuario                                   | 8 |
| 20    | US011     | Inicio de sesión                                      | 8 |
| 21    | US012     | Recuperación de contraseña                            | 5 |
| 22    | US018     | Establecer prioridad de tareas                        | 5 |
| 23    | US020     | Modificación de fechas límite de tareas               | 5 |
| 24    | US021     | Modificación de la prioridad de tareas                | 5 |
| 25    | US022     | Actualización de estado de tareas                     | 5 |
| 26    | US025     | Visualizar calendario de tareas                       | 5 |
| 27    | US028     | Visualizar resumen semanal de avances                 | 5 |
| 28    | US032     | Notificación de nuevo mensaje en proyecto             | 5 |
| 29    | US033     | Notificación de actualización de tareas               | 5 |
| 30    | TS05      | Administración de Usuarios (backend)                  | 5 |
| 31    | TS06      | Manejo de Reportes (backend)                          | 5 |
| 32    | US013     | Cierre de sesión                                      | 3 |
| 33    | US05      | Adaptabilidad móvil                                   | 3 |
| 34    | US06      | Navegación mediante Encabezado                        | 3 |
| 35    | US09      | Pie de página                                         | 3 |
| 36    | US01      | Información general sobre TaskMaster                  | 8 |
| 37    | US02      | Llamado a la acción para descargar la aplicación      | 8 |
| 38    | US08      | About the team                                        | 8 |
| 39    | US03      | Testimonios de usuarios                               | 5 |
| 40    | US04      | Muestra de planes y precios                           | 5 |
| 41    | US07      | Misión y visión                                       | 5 |




### 2.5. Strategic-Level Domain-Driven Design

En esta sección se explica el enfoque utilizado para la toma de decisiones estratégicas en el desarrollo del sistema mediante Domain-Driven Design (DDD). El propósito fue identificar límites naturales del dominio y organizar la solución en Bounded Contexts. Para ello se aplicaron herramientas como Event Storming, que facilitó la exploración de eventos y flujos clave, y el Bounded Context Canvas, que permitió definir objetivos, responsabilidades y relaciones de cada contexto. Este proceso aseguró una visión clara y alineada entre negocio y tecnología.

#### 2.5.1. EventStorming

En esta sección contamos cómo llevamos a cabo la dinámica de EventStorming para tener una primera mirada al dominio. La sesión duró entre 1 y 2 horas, lo que nos ayudó a mantener el foco y aprovechar el tiempo sin que se vuelva pesado. Durante este espacio pudimos identificar los eventos más importantes, quiénes participan y qué acciones los detonan, logrando un mapa general que luego podremos detallar con más calma.

Durante la sesion se inicio una lluvia de ideas, estas ideas fueron escritas con pos-it naranjas, los cuales identificamos como eventos que pasaran en nuestra aplciacion:

![EventStorming](Assets/TB1/paso1.jpg)

##### 2.5.1.1. Candidate Context Discovery
Tras concluir la sesión de Event Storming, el equipo llevó a cabo un análisis de los eventos obtenidos para continuar con los Candidate Context. Este trabajo consistió en agrupar los eventos clave del negocio que indiquen cambios de estado entre diferentes partes del proceso de negocio según sus relaciones y dependencias, identificando patrones que marcan el inicio o fin de procesos clave en la aplicación.

En esta sección se presentan los flujos principales del negocio, que servirán como base para identificar los pivotal events y, a partir de ellos, delimitar los Bounded Contexts que estructurarán el dominio de manera más clara.

![EventStorming](Assets/TB1/segundopaso-1.jpg)
![EventStorming](Assets/TB1/segundopaso-2.jpg)

Una vez definidos y colocados los procesos principales en el tablero de Event Storming, se procedió a identificar e insertar los pain points o puntos de dolor.
Estos representan las fricciones, dudas y frustraciones que experimentan los usuarios y participantes dentro del flujo.

![EventStorming](Assets/TB1/paso2-1.jpg)
![EventStorming](Assets/TB1/paso2-2.jpg)

Una vez mapeados los distintos eventos de dominio, se procedió a destacar aquellos que representan hitos clave en el flujo de negocio. Estos eventos pivotales marcan el inicio o cierre de situaciones críticas, y permiten al equipo comprender cuáles son los puntos más sensibles del sistema. Su identificación resultó esencial, ya que en torno a ellos suelen girar múltiples interacciones e intereses de distintos actores.

![ddd](Assets/TB1/EventStorming-EventStorming_Paso3_PaintPointyPivotalPoints.jpg)

Posteriormente, se identificaron los comandos que dan origen a los eventos, así como los actores responsables de dispararlos. Los actores pueden ser usuarios, sistemas externos o dispositivos que inician acciones dentro del flujo. Este ejercicio permitió clarificar quién inicia los cambios y cómo estos se reflejan en la dinámica del sistema, garantizando una alineación con los objetivos de negocio.

![ddd](Assets/TB1/EventStorming-EventStorming_Paso4_ComandosyUsuarios.jpg)

En esta etapa se reconocieron las políticas, entendidas como reacciones automáticas o manuales a determinados eventos de dominio. Asimismo, se definieron los invariantes de negocio, es decir, las reglas que deben cumplirse obligatoriamente para que un comando pueda ser procesado. Este análisis permitió visibilizar tanto las restricciones que aseguran la coherencia del sistema como las acciones derivadas de los eventos, generando mayor claridad en las condiciones de operación.

![ddd](Assets/TB1/EventStorming-EventStorming_Paso5_Policy.jpg)

Se identificaron los modelos de lectura necesarios para apoyar la toma de decisiones dentro del sistema. Estos modelos representan el estado de la información consolidada en un momento dado y sirven como insumos para validar invariantes, generar reportes o alimentar interfaces de usuario. Su definición fue clave para asegurar que los distintos actores dispongan de la información adecuada y actualizada en cada punto del proceso.

![ddd](Assets/TB1/EventStorming-EventStorming_Paso6_View.jpg)

Después de identificar los agregados en la sesión de Event Storming, analizamos cómo se relacionan entre ellos y también con los sistemas externos. A partir de esto, fuimos agrupando aquellos que tenían vínculos más cercanos y separamos los que apenas interactuaban, marcando así límites de consistencia más claros. 


![ddd](Assets/TB1/BoundedRegistroDeUsuario.PNG)

![ddd](Assets/TB1/boundedgestiondeproyectosytareas.jpg)

![ddd](Assets/TB1/boundedvisualizacion.jpg)

![ddd](Assets/TB1/boundednotificaciones.jpg)

![ddd](Assets/TB1/boundedanalitica.jpg)

##### 2.5.1.2. Domain Message Flows Modeling

Como paso siguiente, se trabajó en la interconexión de los bounded contexts identificados previamente, enfocándonos en reconocer los eventos que sirven como enlace y permiten la comunicación entre los distintos contextos.

Gestión de proyectos y tareas y Notificaciones:
Cada vez que se crea, modifica, elimina o cambia el estado/fecha de una tarea, se genera una notificación automática para los usuarios involucrados, asegurando visibilidad inmediata de los cambios.

![ddd](Assets/TB1/gestion-notificaciones.PNG)

Analítica y Reportes y Notificaciones:
Cuando una tarea es completada o vence su fecha límite, se envía una notificación al responsable o al líder de equipo, permitiendo reaccionar oportunamente a los hitos cumplidos o incumplidos.

![Analítica](Assets/TB1/analitica-notificaciones.PNG)

Gestión de proyectos y tareas y Analítica y Reportes:
Los cambios en asignación de tareas, prioridades y estados alimentan la capa de analítica, donde se generan estadísticas de desempeño tanto a nivel de proyecto como de cada miembro del equipo.

![ddd](Assets/TB1/gestion-analitica.PNG)

Gestión de proyectos y tareas y Visualización y Seguimiento:
Al asignar tareas y actualizar su estado, la información se refleja en herramientas de visualización como tableros o calendarios, facilitando el monitoreo del progreso en tiempo real.

![ddd](Assets/TB1/gestion-visualizacion.PNG)

Analítica y Reportes y Visualización y Seguimiento:
Las métricas obtenidas de proyectos y miembros se proyectan en dashboards y reportes visuales, ofreciendo una vista consolidada del avance y de las áreas que requieren atención.

![ddd](Assets/TB1/analitica-visualizacion.PNG)

IAM y Gestión de proyectos y tareas:
Cuando un usuario se registra e inicia sesión correctamente, obtiene acceso para crear proyectos, asignar tareas y participar en la gestión de actividades dentro del sistema.

![ddd](Assets/TB1/FlowMessageRegistroXGestionProyecto.PNG)

Gestión de proyectos y tareas y Visualización y Seguimiento:
Cada vez que se asigna un miembro, se crea una tarea o se actualiza su estado, esta información se refleja en tableros y calendarios, lo que permite a los usuarios dar seguimiento en tiempo real al progreso del proyecto.

![ddd](Assets/TB1/gestion-visualizacion.PNG)

Visualización y Seguimiento y Analítica y Reportes:
Los cambios en las tareas (como su finalización o vencimiento) alimentan la capa de analítica, donde se recalculan y generan estadísticas actualizadas sobre el rendimiento de los proyectos y de los miembros del equipo.

![ddd](Assets/TB1/visualizacion-analitica.PNG)


##### 2.5.1.3. Bounded Context Canvases

Con el fin de estructurar el dominio del sistema y delimitar responsabilidades claras, se diseñaron los Bounded Context Canvases que representan las principales áreas funcionales de la solución. Cada bounded context define su propósito, los mensajes que intercambia con otros contextos, el lenguaje ubicuo que emplea y las decisiones de negocio que gobiernan su comportamiento.

La separación en bounded contexts permite reducir la complejidad, facilitar la escalabilidad y mantener la coherencia del modelo, garantizando que cada parte del sistema responda a objetivos específicos sin generar dependencias innecesarias.

En este proyecto, los bounded contexts identificados fueron los siguientes:

-Registro y Autenticación de Usuario (IAM): encargado de la validación de identidades y la asignación de roles.

-Gestión de Proyectos y Tareas: núcleo operativo que organiza proyectos, tareas y asignaciones.

-Notificaciones: responsable de generar y distribuir avisos en tiempo real ante eventos relevantes.

-Visualización y Seguimiento: orientado a mostrar el estado de las tareas y proyectos en tableros y calendarios.

A-nalítica y Reportes: especializado en el procesamiento de datos y generación de métricas e informes.

Cada uno de estos bounded contexts se detalla a continuación a través de su canvas, explicando su descripción, clasificación estratégica, roles, comunicaciones entrantes y salientes, lenguaje ubicuo y decisiones de negocio clave.

### *Gestión de Proyectos y Tareas*
Es el núcleo operativo del sistema, ya que gestiona la creación, organización y asignación de proyectos y tareas. Permite a los Team Leaders definir plazos, prioridades y responsables, mientras que los Team Members pueden marcar tareas como completadas. Además, emite eventos clave como “tarea creada” o “tarea vencida”, que sirven como insumo para los bounded contexts de Visualización y Seguimiento, Analítica y Reportes y Notificaciones.

![ddd](Assets/TB1/BoundedCanvasGestionProyectosTareas.PNG)

### *Analítica y Reportes*
Este bounded context se encarga de recopilar y procesar los datos generados en los proyectos y tareas para transformarlos en métricas y reportes. Su propósito principal es ofrecer a los Team Leaders una visión global del estado de los proyectos y a los Team Members un seguimiento de su propio rendimiento. Este contexto asegura la confiabilidad de la información, recalculando estadísticas automáticamente al recibir eventos de tareas completadas o vencidas, y enviando resultados hacia Notificaciones para mantener informados a los usuarios.

![ddd](Assets/TB1/BoundedCanvasAnaliticayReportes.PNG)

### *Visualización y Seguimiento*
Su objetivo es ofrecer a los miembros del equipo una vista clara del estado de las tareas y proyectos mediante tableros y calendarios sincronizados. Este bounded context recibe eventos de Gestión de Proyectos y Tareas (como tareas vencidas o completadas) y los organiza en interfaces visuales para facilitar el monitoreo. Además, se comunica con Analítica y Reportes para mostrar estadísticas y con Notificaciones para resaltar cambios críticos en el estado de las tareas.

![ddd](Assets/TB1/BoundedCanvasVisualizacionSeguimiento.PNG)

### *Registro y Autenticación de Usuario*
Este bounded context asegura la autenticación y gestión de identidades. Permite el registro, inicio de sesión, validación de credenciales y asignación de roles a los usuarios. Su propósito es garantizar que solo usuarios válidos interactúen con el sistema y que cada acción pueda asociarse a un rol definido (Team Leader o Team Member). Se conecta con Gestión de Proyectos y Tareas, ya que solo un usuario autenticado puede crear o unirse a un proyecto.

![ddd](Assets/TB1/BoundedCanvasRegistroUsuario.PNG)

### *Notificaciones*
Este bounded context actúa como un canal de comunicación entre el sistema y los usuarios. Recibe eventos de cambios importantes (como una tarea eliminada, un cambio de fecha límite o la asignación de un miembro) y los transforma en notificaciones enviadas en tiempo real. Su propósito es garantizar la transparencia y la trazabilidad de las acciones realizadas en los proyectos y tareas. Se conecta directamente con Gestión de Proyectos y Tareas y Visualización y Seguimiento, asegurando que los usuarios siempre estén informados.

![ddd](Assets/TB1/BoundedCanvasNotificaciones.PNG)

#### 2.5.2. Context Mapping

El Context Mapping es un proceso clave dentro de la metodología Domain-Driven Design (DDD), utilizado para mapear y visualizar las interacciones y relaciones estructurales entre los diferentes bounded contexts en un sistema. Un bounded context es una delimitación clara en la que un modelo específico tiene validez y significado, y dentro de esa área, las reglas de negocio y los datos son gestionados de forma coherente.

En el caso de **TaskMaster**, nuestra aplicación de gestión de proyectos, el Context Mapping nos permite entender cómo las distintas áreas funcionales del sistema se interconectan. A través de esta visualización, podemos identificar dependencias entre los diferentes dominios, lo que facilita la toma de decisiones sobre la arquitectura y las integraciones de nuestra plataforma. Además, permite entender de manera más clara las responsabilidades de cada contexto y cómo interactúan entre sí.

Se identificaron los siguientes bounded context en el sistema: 

1. Registro y autentificacion de usuario

- Este contexto se encarga de la autenticación y autorización de los usuarios, garantizando que solo las personas autorizadas puedan acceder a las funcionalidades de TaskMaster.

2. Gestión de Proyectos y Tareas

- Se encarga de la creación y gestión de proyectos y tareas, asignando responsables, plazos y prioridades, y permitiendo la distribución organizada del trabajo entre los miembros del equipo.

3. Visualización y Seguimiento

- Permite la visualización de tareas y proyectos a través de diferentes interfaces, como tableros, calendarios, y métricas, para facilitar el seguimiento en tiempo real del progreso y cumplimiento de las fechas de entrega.

4. Analítica y Reportes

- Genera reportes de desempeño y productividad del equipo, utilizando datos de proyectos y tareas, para facilitar la toma de decisiones basadas en datos.

5. Notificaciones

- Maneja el envío de notificaciones a los usuarios, incluyendo tareas asignadas, actualizaciones, y recordatorios sobre fechas límite, asegurando que los miembros del equipo estén informados en tiempo real.

| **Destino (Downstream)**          | **Origen (Upstream)**             | **Tipo de Relación**     | **Comentario**                                                                                                                                                                                               |
| --------------------------------- | --------------------------------- | ------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **Visualización y Seguimiento**   | **Gestión de Proyectos y Tareas** | **Customer/Supplier**    | El contexto de Gestión de Proyectos y Tareas es proveedor de datos de tareas y proyectos, que son consumidos por el contexto de Visualización y Seguimiento.                                                 |
| **Analítica y Reportes**          | **Gestión de Proyectos y Tareas** | **Customer/Supplier**    | Los datos de proyectos y tareas generados en el contexto de Gestión de Proyectos se consumen en Analítica y Reportes para generar informes de desempeño.                                                     |
| **Notificaciones**                | **Gestión de Proyectos y Tareas** | **Customer/Supplier**    | Las actualizaciones de tareas y proyectos en el contexto de Gestión de Proyectos y Tareas generan notificaciones que son enviadas a los usuarios por el contexto de Notificaciones.                          |
| **Notificaciones**                | **Visualización y Seguimiento**   | **Customer/Supplier**    | El contexto de Visualización y Seguimiento puede generar notificaciones para informar a los usuarios sobre el progreso de tareas y cambios en el estado de los proyectos.                                    |
| **Gestión de Proyectos y Tareas** | **Registro y autentificacion de usuario**                           | **Partnership**          | Ambos contextos colaboran estrechamente. Registro y autentificacion de usuario gestiona el acceso de los usuarios, mientras que Gestión de Proyectos y Tareas asegura que las tareas y proyectos sean asignados solo a usuarios autorizados.   |
| **Analítica y Reportes**          | **Notificaciones**                | **Partnership**          | El contexto de Notificaciones puede usar los reportes generados en Analítica y Reportes para crear alertas o notificaciones sobre el desempeño del equipo.                                                   |
| **Registro y autentificacion de usuario**                           | **Todos los Contextos**           | **Shared Kernel**        | La información sobre usuarios, roles y autenticación se comparte entre todos los contextos para garantizar el acceso controlado a las funcionalidades del sistema.                                           |
| **Integraciones Técnicas**        | **Gestión de Proyectos y Tareas** | **Anticorruption Layer** | Si TaskMaster se integra con sistemas externos (por ejemplo, CRM o herramientas de gestión de proyectos), el Anticorruption Layer garantiza que los datos externos no alteren el modelo interno del sistema. |

![ddd](Assets/TB1/Diagram.png)


#### 2.5.3. Software Architecture

En esta sección se presenta de forma breve la arquitectura del sistema TaskMaster: su organización en bounded contexts y contenedores, las responsabilidades principales de cada uno y cómo se comunican entre sí y con sistemas externos. El diseño usa un API Gateway como punto de entrada, servicios independientes para cada dominio (proyectos, visualización/seguimiento, reportes, notificaciones y autenticación) y una base de datos común, buscando modularidad, escalabilidad y facilidad de mantenimiento para el equipo de desarrollo.

##### 2.5.3.1. Software Architecture Context Level Diagrams

En el nivel de contexto se representa de manera general cómo el sistema TaskMaster se relaciona con los usuarios y con otros sistemas externos. En este diagrama se puede observar que los principales actores son el líder de equipo y el integrante de equipo, quienes interactúan con la plataforma a través de la aplicación móvil y la landing page. Además, el sistema mantiene comunicación con servicios externos como Gmail para el envío de notificaciones y Google Calendar para la gestión de plazos y eventos. Este nivel nos ayuda a entender la interacción global del software sin entrar en detalles técnicos complejos.

![ddd](Assets/TB1/ContextDiagram.PNG)

##### 2.5.3.2. Software Architecture Container Level Diagrams

En el nivel de contenedores se desglosan los principales componentes internos de TaskMaster, mostrando cómo está organizado el sistema a nivel tecnológico. Aquí se incluyen la aplicación móvil desarrollada en Kotlin con Jetpack Compose, la Landing Page, el API Gateway como punto central de comunicación, y los diferentes servicios que conforman los bounded contexts, tales como la gestión de proyectos y tareas, visualización y seguimiento, reportes, notificaciones, registro y autenticación de usuarios. Cada uno de estos contenedores cumple una función específica y se conecta entre sí a través de APIs y una base de datos común, lo que garantiza la integración y el correcto funcionamiento de la plataforma.

![ddd](Assets/TB1/ContainerDiagram.PNG)

##### 2.5.3.3. Software Architecture Deployment Diagrams

El diagrama de despliegue representa cómo los principales componentes del sistema TaskMaster se distribuyen en el entorno de producción. En este caso, la aplicación móvil se ejecuta en dispositivos Android de los usuarios, mientras que los servicios principales del backend están alojados en la nube dentro de un clúster de contenedores Node.js. Finalmente, la base de datos se encuentra en un servidor dedicado, asegurando el almacenamiento persistente de la información del sistema. Esta organización permite una arquitectura escalable, separando la lógica de negocio de la capa de presentación y del almacenamiento de datos.

![ddd](Assets/TB1/DeploymentDiagram.PNG)

### 2.6. Tactical-Level Domain-Driven Design

#### 2.6.1. Bounded Context: Registro y autentificacion de usuario

##### 2.6.1.1. Domain Layer

La Domain Layer es el núcleo que orquesta y gestiona las reglas de negocio relacionadas con la autenticación y autorización de usuarios en la plataforma TaskMaster. En este contexto, las entidades como User, Role, y EmailAddress, junto con los servicios y métodos de validación, permiten gestionar la identidad de los usuarios, sus roles, y la verificación de credenciales.

**Objetivo:**

La capa de dominio tiene como objetivo representar las entidades y servicios fundamentales del dominio de la identidad y acceso, cubriendo desde la creación de cuentas hasta la autenticación y autorización para asegurar que solo usuarios autorizados puedan acceder a las funcionalidades del sistema.

**1. Aggregate: User**

**Descripción:**

 El agregado User actúa como la raíz del modelo y encapsula todos los datos y comportamientos relacionados con un usuario del sistema. Esta entidad representa la cuenta de un usuario y contiene las credenciales, roles y la información necesaria para la autenticación. En la base de datos, se representa con la tabla users.

| **Atributo** | **Tipo**  | **Descripción**                                       |
| ------------ | --------- | ----------------------------------------------------- |
| `id`         | Int      | Identificador único del usuario (autogenerado).       |
| `username`   | String    | Nombre de usuario único para identificar al usuario.  |
| `password`   | String    | Contraseña de acceso del usuario.                     |
| `roles`      | Set<Role> | Conjunto de roles asignados al usuario. (TEAM_MEMBER, TEAM_LEADER).              |
| `email`      | String    | Dirección de correo electrónico validada del usuario. |
| `createdAt`  | Date      | Fecha de creación del usuario.                        |
| `updatedAt`  | Date      | Fecha de última actualización del usuario.            |

**Métodos:**
- addRoles(List<Role> roles): Añade un conjunto de roles al usuario, retornando el usuario con los roles actualizados.

- getAuthorities(): Retorna el conjunto de roles del usuario, implementando la interfaz GrantedAuthority, permitiendo la integración con Spring Security para la autorización de acceso.

- isAccountNonExpired(): Retorna true si la cuenta del usuario no ha expirado.

- isAccountNonLocked(): Retorna true si la cuenta del usuario no está bloqueada.

- isCredentialsNonExpired(): Retorna true si las credenciales del usuario no han expirado.

- isEnabled(): Retorna true si la cuenta está habilitada.

- getUsername(): Retorna el nombre de usuario.

- getPassword(): Retorna la contraseña del usuario.

**2. Value Object: EmailAddress**

**Descripción:**

 El objeto de valor EmailAddress representa una dirección de correo electrónico válida. Es un objeto embebido que valida y maneja los datos relacionados con la dirección de correo.

| **Atributo** | **Tipo** | **Descripción**                                                                          |
| ------------ | -------- | ---------------------------------------------------------------------------------------- |
| `email`      | String   | Dirección de correo electrónico validada (máx. 50 caracteres, formato válido de correo). |


**Métodos:**
- EmailAddress(String email): Constructor que recibe un correo electrónico y lo valida según las restricciones del formato y longitud.

- EmailAddress(): Constructor por defecto que inicializa el objeto con un valor null.

**3. Value Object: Role**

**Descripción:**

El objeto de valor Role define los roles de los usuarios en TaskMaster. Los roles son TEAM_MEMBER y TEAM_LEADER, y están representados como valores enumerados. Los roles son fundamentales para determinar los permisos y el acceso dentro de la plataforma.

| Atributo | Tipo       | Descripción                                              |
|----------|------------|----------------------------------------------------------|
| name     | RoleEnum   | Nombre del rol, representado como un valor enumerado (TEAM_MEMBER, TEAM_LEADER). |

**Métodos:**
- `getStringName()`: Retorna el nombre del rol como una cadena de texto.
- `getDefaultRole()`: Retorna el rol predeterminado del sistema, en este caso TEAM_MEMBER.
- `toRoleFromName(String name)`: Convierte el nombre de un rol en una instancia del objeto Role.
- `validateRoleSet(List<Role> roles)`: Valida un conjunto de roles, retornando el rol predeterminado (TEAM_MEMBER) si el conjunto está vacío o nulo.
- `getAuthority()`: Retorna el nombre del rol, implementando la interfaz GrantedAuthority para la integración con Spring Security.

**4. Entity: Role**

**Descripción:**
La entidad Role representa los roles de un usuario dentro del sistema y define los permisos y responsabilidades asociados. Se utiliza para realizar las comprobaciones de seguridad y autorización en las funcionalidades del sistema.

| Atributo | Tipo       | Descripción                                              |
|----------|------------|----------------------------------------------------------|
| id       | int       | Identificador único del rol.                             |
| name     | String     | Nombre del rol, definido como un valor de enumeración (TEAM_MEMBER, TEAM_LEADER). |

**Métodos:**
- `getStringName()`: Retorna el nombre del rol como una cadena de texto.
- `getDefaultRole()`: Devuelve el rol predeterminado del sistema (TEAM_MEMBER).
- `toRoleFromName(String name)`: Convierte el nombre de un rol en una instancia de la entidad Role.
- `validateRoleSet(List<Role> roles)`: Valida un conjunto de roles y retorna el rol predeterminado si no se encuentra ningún rol.
- `getAuthority()`: Devuelve el nombre del rol, implementando la interfaz GrantedAuthority para la integración con Spring Security.

**5. Domain Service: AuthenticationService**

**Descripción:**
El servicio AuthenticationService encapsula las reglas de negocio relacionadas con la autenticación, validando las credenciales del usuario y gestionando los procesos de inicio de sesión, cierre de sesión y recuperación de contraseñas.

**Métodos:**
- `authenticate(String username, String password)`: Valida las credenciales del usuario y autentica al mismo.
- `logout(User user)`: Finaliza la sesión del usuario, invalidando el token de acceso o sesión.
- `resetPassword(String email)`: Inicia el proceso de recuperación de contraseña, enviando un enlace de restablecimiento al correo electrónico registrado.

**6. Repository: UserRepository**

**Descripción:**
El UserRepository es una abstracción para la persistencia de los usuarios en la base de datos, permitiendo realizar operaciones CRUD de manera efectiva.

**Métodos:**
- `save(User user)`: Guarda un nuevo usuario o actualiza uno existente en la base de datos.
- `findByUsername(String username)`: Recupera un usuario por su nombre de usuario.
- `findByEmail(String email)`: Recupera un usuario por su correo electrónico.
- `findById(Long id)`: Recupera un usuario por su identificador único.

**En la Domain Layer de TaskMaster**, hemos definido los roles como TEAM_MEMBER y TEAM_LEADER dentro de un modelo de Domain-Driven Design (DDD). Estas entidades y objetos de valor representan las reglas de negocio fundamentales del sistema de autenticación y autorización. La clase User se asocia con los roles, y se valida el acceso y las credenciales a través de servicios como AuthenticationService y repositorios como UserRepository.

### 2.6.1.2. Interface Layer

La Interface Layer es la capa que expone los endpoints de la aplicación, permitiendo la interacción entre los usuarios y el sistema. Los controladores son responsables de recibir las peticiones, validarlas y coordinar con los servicios correspondientes para ejecutar las acciones solicitadas. En esta capa, no se implementan reglas de negocio, sino que se coordina la comunicación entre las solicitudes de los usuarios y la lógica del dominio.

**Controlador: AuthenticationController**

**Descripción:**
El `AuthenticationController` maneja los endpoints relacionados con la autenticación de los usuarios. Este controlador es responsable del inicio de sesión (signIn), el registro de nuevos usuarios (signUp), y otros procesos relacionados con la autenticación.

| Método   | Ruta                             | Descripción                                                                                  |
|----------|----------------------------------|----------------------------------------------------------------------------------------------|
| signIn   | POST /api/v1/authentication/sign-in  | Maneja la solicitud de inicio de sesión. Recibe un objeto `SignInResource` y llama al servicio de autenticación. Si la autenticación es exitosa, devuelve un recurso de usuario autenticado. Si falla, retorna un error 401. |
| signUp   | POST /api/v1/authentication/sign-up  | Maneja la solicitud de registro de nuevos usuarios. Recibe un objeto `SignUpResource`, lo convierte en un comando, y llama al servicio para registrar al usuario. Si es exitoso, devuelve el recurso de usuario creado. Si hay un error, retorna un error 400. |

**Dependencias:**
- `UserCommandService`: Servicio que maneja los comandos de creación y autenticación de usuarios.
- `SignInCommandFromResourceAssembler`: Utilidad para convertir el recurso de inicio de sesión en un comando.
- `SignUpCommandFromResourceAssembler`: Utilidad para convertir el recurso de registro en un comando.
- `AuthenticatedUserResourceFromEntityAssembler`: Utilidad para convertir el usuario autenticado en un recurso.
- `UserResourceFromEntityAssembler`: Utilidad para convertir el usuario registrado en un recurso.

**Controlador: RolesController**

**Descripción:**
El `RolesController` maneja los endpoints relacionados con la gestión de roles. Los roles, en este caso, son `TEAM_MEMBER` y `TEAM_LEADER`, y se usan para determinar los permisos de acceso dentro del sistema.

| Método       | Ruta                           | Descripción                                                                         |
|--------------|--------------------------------|-------------------------------------------------------------------------------------|
| getAllRoles  | GET /api/v1/roles              | Maneja la solicitud para obtener todos los roles. Llama al servicio de consultas, obtiene la lista de roles y los convierte en recursos para la respuesta. Devuelve una lista de recursos de roles. |

**Dependencias:**
- `RoleQueryService`: Servicio encargado de manejar las consultas relacionadas con roles.
- `GetAllRolesQuery`: Consulta que se utiliza para obtener todos los roles.
- `RoleResourceFromEntityAssembler`: Utilidad para convertir las entidades de roles en recursos para enviarlos en la respuesta.

**Controlador: UsersController**

**Descripción:**
El `UsersController` maneja los endpoints relacionados con la gestión de usuarios. Permite obtener todos los usuarios, obtener un usuario específico por su ID, y actualizar ciertos datos del usuario, como el estado de verificación del apoderado.

| Método                    | Ruta                                | Descripción                                                                                           |
|---------------------------|-------------------------------------|-------------------------------------------------------------------------------------------------------|
| getAllUsers               | GET /api/v1/users                   | Maneja la solicitud para obtener todos los usuarios. Llama al servicio de consultas y devuelve la lista de usuarios. |
| getUserById               | GET /api/v1/users/{userId}          | Maneja la solicitud para obtener un usuario específico por su ID. Si el usuario existe, lo convierte en un recurso y lo devuelve. Si no, retorna un error 404. |
| updateProofingApoderado   | PUT /api/v1/users/{userId}/update-proofing | Maneja la solicitud para actualizar el estado de verificación de un apoderado. Recibe un objeto `UpdateProofingApoderadoResource` y lo convierte en un comando para actualizar el estado. Si la operación es exitosa, devuelve un mensaje de éxito. |

**Dependencias:**
- `UserQueryService`: Servicio encargado de manejar las consultas relacionadas con usuarios.
- `UserCommandService`: Servicio encargado de manejar los comandos relacionados con la gestión de usuarios.
- `GetAllUsersQuery`: Consulta que se utiliza para obtener todos los usuarios.
- `GetUserByIdQuery`: Consulta que se utiliza para obtener un usuario específico por su ID.
- `UpdateProofingApoderadoCommandFromResourceAssembler`: Utilidad para convertir el recurso de actualización de verificación en un comando.
- `UserResourceFromEntityAssembler`: Utilidad para convertir las entidades de usuario en recursos que se envían en la respuesta.

**Flujo de Trabajo:**
- **Autenticación**: Los usuarios pueden registrarse (signUp) o iniciar sesión (signIn) a través de la API, lo que invoca los servicios correspondientes para crear una cuenta o validar credenciales.
- **Gestión de Roles**: Los administradores pueden consultar los roles disponibles a través del endpoint de roles.
- **Gestión de Usuarios**: Los usuarios y administradores pueden consultar la lista de usuarios, obtener información específica de un usuario o actualizar ciertos datos como el estado de verificación de un apoderado.

En esta capa, los controladores son los encargados de recibir las solicitudes HTTP, dirigirlas a los servicios apropiados, y devolver una respuesta adecuada. Estos controladores no contienen reglas de negocio, sino que delegan el procesamiento a la capa de dominio o los servicios, actuando como una interfaz entre los usuarios y la lógica del negocio. Los controladores presentados permiten gestionar la autenticación de usuarios, la gestión de roles, y la administración de usuarios dentro del sistema TaskMaster.

### 2.6.1.3. Application Layer

La **Application Layer** es responsable de coordinar la lógica de negocio que se ejecuta en respuesta a los comandos y consultas. Aquí, los **Command Handlers** manejan la creación, actualización y eliminación de datos, mientras que los **Query Handlers** gestionan las consultas para obtener información del sistema. Además, esta capa garantiza que todas las verificaciones y reglas de negocio se implementen antes de que la información se procese o se persista.

**Servicio: UserCommandServiceImpl**

**Descripción:**
El `UserCommandServiceImpl` maneja los comandos relacionados con los usuarios, como el registro de nuevos usuarios, inicio de sesión, y la actualización del estado de verificación de apoderados. Este servicio coordina la creación de nuevos usuarios, la autenticación y la modificación de sus datos.

| Método                           | Descripción                                                                                                                                 |
|----------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------|
| handle(SignUpCommand)           | Maneja el comando de registro de un nuevo usuario. Verifica la unicidad del nombre de usuario y correo electrónico. Si todo es válido, crea un nuevo usuario, lo guarda en el repositorio y devuelve el usuario creado. |
| handle(SignInCommand)           | Maneja el comando de inicio de sesión. Verifica las credenciales del usuario (nombre de usuario y contraseña). Si es válido, genera un token de autenticación y lo devuelve junto con los datos del usuario. |
| updateProofingApoderado(UpdateProofingApoderadoCommand) | Actualiza el estado de verificación de apoderado para un usuario. Verifica que el usuario tenga el rol adecuado y actualiza su estado en el repositorio. |

**Dependencias:**
- `UserRepository`: Repositorio encargado de la persistencia de los usuarios.
- `HashingService`: Servicio para la codificación y validación de contraseñas.
- `TokenService`: Servicio que genera tokens de autenticación para los usuarios.
- `RoleRepository`: Repositorio encargado de gestionar los roles de los usuarios.
- `User`: Entidad que representa a un usuario.
- `SignUpCommand`: Comando para registrar un nuevo usuario.
- `SignInCommand`: Comando para iniciar sesión con un usuario.
- `UpdateProofingApoderadoCommand`: Comando para actualizar el estado de verificación de apoderado.

**Servicio: UserQueryServiceImpl**

**Descripción:**
El `UserQueryServiceImpl` maneja las consultas relacionadas con los usuarios, permitiendo obtener información sobre los usuarios registrados. Este servicio es responsable de devolver los usuarios por su nombre, ID, o todos los usuarios registrados.

| Método                           | Descripción                                                                                               |
|----------------------------------|-----------------------------------------------------------------------------------------------------------|
| handle(GetUserByUsernameQuery)  | Maneja la consulta para obtener un usuario por su nombre de usuario. Devuelve un `Optional<User>` que puede estar vacío si no se encuentra el usuario. |
| handle(GetUserByIdQuery)        | Maneja la consulta para obtener un usuario por su ID. Devuelve un `Optional<User>` que puede estar vacío si no se encuentra el usuario. |
| handle(GetAllUsersQuery)        | Maneja la consulta para obtener todos los usuarios registrados. Devuelve una lista de objetos `User`. |

**Dependencias:**
- `UserRepository`: Repositorio encargado de la persistencia de los usuarios.
- `User`: Entidad que representa a un usuario.
- `GetUserByUsernameQuery`: Consulta para obtener un usuario por nombre de usuario.
- `GetUserByIdQuery`: Consulta para obtener un usuario por su ID.
- `GetAllUsersQuery`: Consulta para obtener todos los usuarios.

**Servicio: RoleCommandServiceImpl**

**Descripción:**
El `RoleCommandServiceImpl` maneja los comandos relacionados con los roles, incluyendo la creación y inicialización de roles. En este caso, nos aseguramos de que los roles esenciales como `TEAM_MEMBER` y `TEAM_LEADER` estén presentes en el sistema.

| Método                          | Descripción                                                                                     |
|---------------------------------|-------------------------------------------------------------------------------------------------|
| handle(SeedRolesCommand)        | Maneja el comando para inicializar los roles en el sistema. Verifica si los roles ya existen en el repositorio. Si no, los crea y los guarda. |
| handle(CreateRoleCommand)       | Maneja el comando para crear un nuevo rol. Verifica si el rol ya existe antes de crearlo. |

**Dependencias:**
- `RoleRepository`: Repositorio encargado de la persistencia de los roles.
- `Role`: Entidad que representa un rol en el sistema.
- `SeedRolesCommand`: Comando para inicializar los roles en el sistema.
- `CreateRoleCommand`: Comando para crear un nuevo rol en el sistema.

**Servicio: RoleQueryServiceImpl**

**Descripción:**
El `RoleQueryServiceImpl` maneja las consultas relacionadas con los roles, permitiendo obtener información sobre los roles existentes, como `TEAM_MEMBER` y `TEAM_LEADER`.

| Método                          | Descripción                                                                                 |
|---------------------------------|---------------------------------------------------------------------------------------------|
| handle(GetAllRolesQuery)        | Maneja la consulta para obtener todos los roles registrados en el sistema. Devuelve una lista de objetos `Role`. |
| handle(GetRoleByNameQuery)      | Maneja la consulta para obtener un rol por su nombre. Devuelve un `Optional<Role>` que puede estar vacío si no se encuentra el rol. |

**Dependencias:**
- `RoleRepository`: Repositorio encargado de la persistencia de los roles.
- `Role`: Entidad que representa un rol en el sistema.
- `GetAllRolesQuery`: Consulta para obtener todos los roles registrados.
- `GetRoleByNameQuery`: Consulta para obtener un rol por nombre.

**Flujos de Comandos y Consultas:**

**Comandos:**

- **Registro de usuario (SignUpCommand):**  
  El servicio `UserCommandServiceImpl` maneja el comando `SignUpCommand`, que crea un nuevo usuario verificando la unicidad del nombre de usuario y correo electrónico. Si los datos son válidos, el usuario es creado y almacenado en el repositorio.

- **Inicio de sesión (SignInCommand):**  
  El servicio `UserCommandServiceImpl` maneja el comando `SignInCommand`, que valida las credenciales del usuario (nombre de usuario y contraseña), genera un token de autenticación y lo devuelve junto con los datos del usuario.

- **Actualización de verificación de apoderado (UpdateProofingApoderadoCommand):**  
  Este comando es manejado por `UserCommandServiceImpl` y permite actualizar el estado de verificación de un apoderado para un usuario.

**Consultas:**

- **Obtener un usuario por nombre de usuario (GetUserByUsernameQuery):**  
  El servicio `UserQueryServiceImpl` maneja esta consulta y devuelve un usuario si se encuentra en el sistema, o un `Optional.empty()` si no se encuentra.

- **Obtener un usuario por ID (GetUserByIdQuery):**  
  Similar a la consulta anterior, esta consulta busca un usuario por su ID y devuelve un `Optional<User>`.

- **Obtener todos los usuarios (GetAllUsersQuery):**  
  Devuelve una lista con todos los usuarios registrados en el sistema.

##### 2.6.1.4. Infrastructure Layer

La capa de infraestructura gestiona la comunicación con sistemas externos, incluyendo la base de datos relacional. En este contexto, los repositorios se encargan de la persistencia de los datos del dominio, asegurando que la lógica de negocio en capas superiores no se acople a la tecnología de almacenamiento.

Esta capa alberga los componentes de repositorio, que son los responsables de mantener la persistencia de las entidades `User` y `Role` y de gestionar la relación entre ellas.


**Repositorio: UserRepository**

**Descripción**: Repositorio que maneja las operaciones de persistencia relacionadas con los usuarios en la base de datos.
| Método | Descripción |
| :--- | :--- |
| `save(User user)` | Guarda un nuevo usuario o actualiza uno existente en la base de datos. |
| `findByUsername(String username)` | Busca un usuario por su nombre de usuario. Devuelve un `Optional<User>` para manejar la posible ausencia del usuario. |
| `existsByUsername(String username)` | Verifica si un usuario con el nombre de usuario especificado ya existe en la base de datos. Devuelve un `boolean`. |
| `findById(Long id)` | Busca un usuario por su ID. Devuelve un `Optional<User>`. |
| `findAll()` | Devuelve una lista de todos los usuarios almacenados en la base de datos. |

**Dependencias**:
* **`User`**: Clase que representa la entidad del usuario en el sistema.

**Repositorio: RoleRepository**

**Descripción**: Repositorio que maneja las operaciones de persistencia relacionadas con los roles.
| Método | Descripción |
| :--- | :--- |
| `save(Role role)` | Guarda un nuevo rol o actualiza uno existente en la base de datos. |
| `findByName(String name)` | Busca un rol por su nombre (ej. "Team Leader"). Devuelve un `Optional<Role>`. |
| `findById(Long id)` | Busca un rol por su ID. Devuelve un `Optional<Role>`. |
| `findAll()` | Devuelve una lista de todos los roles almacenados en la base de datos. |

**Dependencias**:
* **`Role`**: Clase que representa un rol en el sistema.

**Repositorio: UserRoleRepository**

**Descripción**: Repositorio que gestiona la relación de asignación de roles entre usuarios y roles en la tabla de unión `User_Roles`.
| Método | Descripción |
| :--- | :--- |
| `assignRoleToUser(Long userId, Long roleId)` | Asigna un rol a un usuario, creando un nuevo registro en la tabla de unión. |
| `findRolesByUserId(Long userId)` | Devuelve una lista de todos los roles asignados a un usuario específico. |
| `findByUserIdAndRoleId(Long userId, Long roleId)` | Verifica si un usuario ya tiene un rol específico. |

**Dependencias**:
* **`User`**: Clase que representa la entidad del usuario.
* **`Role`**: Clase que representa la entidad del rol.
* **`UserRole`**: Clase que representa la relación entre un usuario y un rol.

##### 2.6.1.5. Bounded Context Software Architecture Component Level Diagrams

##### 2.6.1.6. Bounded Context Software Architecture Code Level Diagrams

###### 2.6.1.6.1. Bounded Context Domain Layer Class Diagrams

El diagrama de clases para la Capa de Dominio en el contexto delimitado de "Registro y autentificación de usuario" es el componente central que representa la estructura y la lógica de negocio del sistema. Este diagrama se centra en las entidades, objetos de valor e interfaces, así como en sus relaciones, con un alto nivel de detalle. El propósito principal es modelar con precisión las reglas de autenticación y autorización para asegurar la coherencia y la integridad de los datos, siguiendo los principios de Domain-Driven Design (DDD).

**1. Capa de Dominio (Domain Layer)**

Esta es el **corazón** del sistema y el lugar donde residen las **reglas de negocio**. Su propósito principal es modelar el negocio de manera precisa, encapsulando la lógica y el comportamiento de las entidades principales. En esta capa, las clases no tienen conocimiento de cómo se guardan o se presentan los datos; solo se preocupan por el negocio.

* **Agregados (Aggregates)**: Son clústeres de objetos que se tratan como una única unidad transaccional. En tu diagrama, **`User`** es el agregado principal, el cual asegura la integridad de los datos relacionados, como la información del usuario y sus roles.
* **Entidades (Entities)**: Objetos con una **identidad única y persistente** a lo largo del tiempo. **`Role`** es una entidad, ya que tiene un `id` y su propia existencia dentro del sistema.
* **Objetos de Valor (Value Objects)**: Objetos inmutables que no tienen una identidad única; se definen por sus atributos. **`EmailAddress`** y **`Roles`** (la enumeración) son ejemplos de objetos de valor, que describen una característica o cualidad de una entidad.

---

**2. Capa de Aplicación (Application Layer)**

Esta capa actúa como un **orquestador**. Recibe comandos y consultas de la capa de interfaz y coordina la ejecución de la lógica del negocio. Es el "intermediario" que traduce las peticiones de los usuarios en acciones del dominio, asegurando que las reglas de negocio se apliquen correctamente.

* **Servicios de Comando y Consulta**: Las implementaciones de `UserCommandService` y `UserQueryService` son responsables de las transacciones (escribir datos) y las consultas (leer datos), respectivamente. Estos servicios usan los repositorios para interactuar con el dominio.
* **Servicios Externos (Outbounded Services)**: Se utilizan para manejar operaciones técnicas que no forman parte de la lógica de negocio principal, como la encriptación de contraseñas (`HashingService`) o la generación de tokens (`TokenService`). Esta separación mantiene el dominio limpio de preocupaciones técnicas.

---

**3. Capa de Infraestructura (Infrastructure Layer)**

Esta capa se encarga de los detalles técnicos y de la **persistencia**. Proporciona las herramientas necesarias para que la capa de aplicación pueda ejecutar sus tareas.

* **Implementación de Repositorios**: Aquí se encuentran las clases concretas (`UserRepositoryImpl`, `RoleRepositoryImpl`) que implementan las interfaces de repositorio del dominio. Estas clases contienen la lógica para interactuar con la base de datos (por ejemplo, a través de SQL o una ORM), guardando y recuperando las entidades del dominio.

---

**4. Capa de Interfaces (Interfaces Layer)**

Esta es la **capa de presentación** y el **punto de entrada** de la aplicación. Se encarga de la comunicación con el mundo exterior. Su única responsabilidad es recibir las solicitudes y convertirlas en un formato que la capa de aplicación pueda entender.

* **Controladores**: Clases como `UsersController` y `AuthenticationController` son los **controladores REST** que exponen los _endpoints_ de la API. Reciben las peticiones HTTP y delegan la lógica a la capa de aplicación.
* **Recursos (Resources)**: Son objetos de transferencia de datos (DTOs) que representan la información de entrada y salida de la API. Por ejemplo, `SignInResource` contiene los datos necesarios para iniciar sesión.
* **Assemblers**: Son utilidades que convierten las entidades del dominio en objetos `Resource` y viceversa. Esto **desacopla** la API del modelo de dominio, lo que permite modificar el formato de la API sin afectar la lógica de negocio.

![ddd](Assets/TB1/IAM.png)

###### 2.6.1.6.2. Bounded Context Database Design Diagrams

El diagrama de base de datos para el **Bounded Context Registro y autentificacion de usuario** detalla el esquema relacional simplificado que soporta el registro y la asignación de roles de los usuarios. Este diseño se centra en la identidad y el acceso, encapsulando la lógica de negocio necesaria para estos procesos.

**Descripción del Diagrama**

* **Tabla `Users`**: Esta es la entidad principal que representa a un usuario en el sistema. Contiene el identificador único `id` (PK), el `username` (VARCHAR), el `password` hasheado (VARCHAR), un campo `proofing_apoderado` y metadatos de auditoría como `created_at` y `updated_at`. Para garantizar la unicidad y el manejo de la identidad, el `username` debe ser único. El campo `password` almacena la contraseña de forma segura (hasheada).

* **Tabla `Roles`**: Esta tabla define los roles predefinidos en la aplicación, como "Team Leader" y "Team Member". Contiene un `id` (PK) para identificar cada rol y un `name` (VARCHAR) que describe el rol.

* **Tabla de Unión `User_Roles`**: Esta tabla implementa la relación **muchos-a-muchos** entre `Users` y `Roles`. Permite que un usuario tenga múltiples roles y que un rol sea asignado a múltiples usuarios. La tabla incluye dos claves foráneas (`user_id` y `role_id`) que referencian las tablas `Users` y `Roles`, respectivamente. La combinación de estas dos claves forma una **clave primaria compuesta**, asegurando que un usuario no pueda tener el mismo rol asignado más de una vez.

**Relaciones Clave**

La conexión entre las tablas `Users` y `Roles` se visualiza a través de la tabla `User_Roles`. Las flechas del diagrama (crow's foot notation) ilustran esta cardinalidad:

* Una fila en la tabla `Users` puede estar asociada a muchas filas en la tabla `User_Roles`.
* Una fila en la tabla `Roles` puede estar asociada a muchas filas en la tabla `User_Roles`.

![ddd](Assets/TB1/boundedIAM.jpg)


#### 2.6.2. Bounded Context: Notificaciones

##### 2.6.2.1. Domain Layer

##### 2.6.2.2. Interface Layer

##### 2.6.2.3. Application Layer

##### 2.6.2.4. Infrastructure Layer

##### 2.6.2.5. Bounded Context Software Architecture Component Level Diagrams

##### 2.6.2.6. Bounded Context Software Architecture Code Level Diagrams

###### 2.6.2.6.1. Bounded Context Domain Layer Class Diagrams

###### 2.6.2.6.2. Bounded Context Database Design Diagrams

#### 2.6.2. Bounded Context: Analítica y Reportes
#### 2.6.1.1. Domain Layer
Este bounded context consume datos de:
- **Gestión de proyectos y tareas**: `projectId`, `fechas de inicio/fin`, `presupuesto`, `lista de Miembros de equipo`, `lista de Tareas del proyecto (estado, prioridad, overdue, assignedAt, completedAt)`.
- **Registro y autenticación**: `Miembros de equipo con costo por hora`.

Con esa información calcula y expone:
- **Estadísticas por Proyecto** (Project Dashboard, visible para el Team Leader).
- **Estadísticas por Miembro** (Member Dashboard, visible para el Team Leader).
- **Progress** (vista personal del Team Member).

A continuación se listan los **aggregates**, **entities**, **value objects** y **repositories**.

---

## 1. Aggregate: ProjectAnalytics
Reúne la información para entender el estado global del **Proyecto**: producción de tareas, tiempos promedio, uso de presupuesto y comparación de miembros.

**Atributos**

| Atributo        | Tipo                   | Visibilidad | Descripción |
|-----------------|------------------------|-------------|-------------|
| `projectId`     | int                    | Private     | Proyecto al que pertenecen las métricas. |
| `period`        | `DateRange`            | Private     | Rango de fechas considerado. |
| `taskStats`     | `TaskStats`            | Private     | Conteos por estado (incluye `overdue` y `total`). |
| `avgMetrics`    | List<`AverageMetric`>  | Private     | Horas promedio por estado o prioridad. |
| `budget`        | `BudgetUsage`          | Private     | Aprobado, usado y diferencia. |
| `members`       | List<`MemberSnapshot`> | Private     | Resumen por miembro (producción y costo). |
| `bestMemberId`  | int                    | Private     | Miembro destacado según criterio. |
| `worstMemberId` | int                    | Private     | Miembro con menor desempeño. |
| `rankingReason` | String                 | Private     | Motivo corto del ranking. |

**Métodos**

| Método                                                | Retorno | Descripción |
|-------------------------------------------------------|---------|-------------|
| `ingestTasks(List<Task> tasks)`                       | `void`  | Integra tareas del periodo y actualiza métricas. |
| `ingestMembers(List<MemberSnapshot> members)`         | `void`  | Sincroniza datos de miembros. |
| `updateBudget(Money approved, Money usedDelta)`       | `void`  | Ajusta el presupuesto aprobado y el usado. |
| `recalculateAverages()`                               | `void`  | Recalcula promedios por estado y prioridad. |
| `recalculateRanking(String criteria, String priorityCode, String statusCode)` | `void` | Determina `bestMemberId` y `worstMemberId`. |
| `reset()`                                             | `void`  | Limpia métricas derivadas para recalcular. |

**Reglas clave**
- Los conteos deben cuadrar con la suma de tareas por estado.
- El presupuesto usado no debe superar el presupuesto aprobado.

---

## 2. Aggregate: MemberAnalytics
Mide el desempeño de un Team Member en el proyecto.

**Atributos**

| Atributo      | Tipo                  | Visibilidad | Descripción |
|---------------|-----------------------|-------------|-------------|
| `projectId`   | int                   | Private     | Proyecto al que pertenece. |
| `memberId`    | int                   | Private     | Miembro evaluado. |
| `period`      | `DateRange`           | Private     | Rango de fechas considerado. |
| `taskStats`   | `TaskStats`           | Private     | Conteos por estado del miembro. |
| `avgMetrics`  | List<`AverageMetric`> | Private     | Horas promedio por estado o prioridad. |
| `hourlyRate`  | `Money`               | Private     | Tarifa por hora. |
| `spentHours`  | Float                 | Private     | Horas invertidas. |
| `cost`        | `Float`               | Private     | Costo total del miembro. |

**Métodos**

| Método                          | Retorno | Descripción |
|---------------------------------|---------|-------------|
| `ingestTasks(List<Task> tasks)` | `void`  | Integra tareas del miembro y actualiza métricas. |
| `setHourlyRate(Money rate)`     | `void`  | Define o ajusta la tarifa por hora. |
| `recalculateHours()`            | `float` | Recalcula horas invertidas. |
| `recalculateCost()`             | `Float` | Recalcula el costo total del miembro. |
| `recalculateAverages()`         | `void`  | Recalcula promedios por estado y prioridad. |
| `velocity()`                    | `float` | Velocidad del miembro. |
| `reset()`                       | `void`  | Limpia métricas derivadas para recalcular. |

**Reglas clave**
- El costo total debe ser coherente con `tarifa × horas`.
- Las horas invertidas no pueden ser negativas.

---

## 3. Value Object: DateRange
Ventana de tiempo usada para los cálculos.

| Atributo | Tipo      | Descripción |
|---------|-----------|-------------|
| `start` | LocalDate | Inicio del rango (incluido). |
| `end`   | LocalDate | Fin del rango (incluido). |

**Reglas clave**
- La fecha de inicio debe ser anterior o igual a la fecha de fin.

---

## 4. Value Object: TaskStats
Conteo rápido de cómo van las tareas.

| Atributo     | Tipo | Descripción |
|--------------|------|-------------|
| `total`      | Int  | Total de tareas. |
| `notStarted` | Int  | No iniciadas. |
| `inProgress` | Int  | En progreso. |
| `done`       | Int  | Completadas. |
| `overdue`    | Int  | Vencidas. |

**Reglas clave**
- El total debe coincidir con la suma de los estados.

---

## 5. Value Object: AverageMetric
Promedio de horas para un estado o prioridad.

| Atributo    | Tipo   | Descripción |
|-------------|--------|-------------|
| `dimension` | String | STATUS o PRIORITY. |
| `code`      | String | Código de estado o prioridad. |
| `avgHours`  | Float  | Horas promedio. |

---

## 6. Value Object: BudgetUsage
Cómo va el presupuesto del proyecto.

| Atributo   | Tipo    | Descripción |
|------------|---------|-------------|
| `approved` | `Float` | Presupuesto aprobado. |
| `used`     | `Float` | Suma de costos utilizados. |
| `variance` | `Float` | Diferencia entre aprobado y usado. |

---

## 7. Repository: ProjectAnalyticsRepository
Persistencia de `ProjectAnalytics`.

**Métodos**
- `findByProjectId(int projectId)` — Recupera las métricas del proyecto.  
- `save(ProjectAnalytics aggregate)` — Guarda o actualiza el agregado.

---

## 8. Repository: MemberAnalyticsRepository
Persistencia de `MemberAnalytics`.

**Métodos**
- `findByProjectIdAndMemberId(int projectId, int memberId)` — Recupera métricas de un miembro.  
- `save(MemberAnalytics aggregate)` — Guarda o actualiza el agregado.

---

En la Domain Layer de Analítica y Reportes, este modelo recibe tareas y miembros desde otros bounded contexts, calcula conteos, promedios, costos y presupuesto dentro de los **Aggregates** y persiste las métricas a través de los **Repositories** para que el frontend pueda visualizar dashboards (Project, Member y Progress) con datos confiables **sin historial ni descargas**.

#### 2.6.1.2. Interface Layer

La Interface Layer expone los endpoints HTTP (REST + JSON) que permiten al frontend **generar y consultar métricas vivas** para el Project Dashboard, Member Dashboard y la vista de Progress (personal).  
En esta capa no hay reglas de negocio: los controladores reciben las peticiones, validan formato, convierten recursos a comandos/consultas y delegan en los servicios de la Application Layer.

---

## Controlador: **AnalyticsController**

Gestiona métricas de **Proyecto** y **Miembro**, ranking y presupuesto.

### Métodos

| Método | Ruta | Descripción |
|---|---|---|
| `POST` | `/api/v1/projects/{projectId}/analytics/generate` | `generateProjectAnalytics()` — Dispara el cálculo/actualización de métricas del proyecto para un rango de fechas. |
| `GET`  | `/api/v1/projects/{projectId}/analytics` | `getProjectAnalytics()` — Retorna métricas actuales del proyecto (`ProjectAnalyticsDTO`) para un rango. |
| `POST` | `/api/v1/projects/{projectId}/ranking/recalculate` | `recalculateRanking()` — Recalcula `bestMemberId`, `worstMemberId` y `rankingReason` con criterio y filtros opcionales. |
| `GET`  | `/api/v1/projects/{projectId}/ranking` | `getProjectRanking()` — Devuelve el ranking actual del proyecto. |
| `PATCH`| `/api/v1/projects/{projectId}/budget` | `updateProjectBudget()` — Actualiza presupuesto aprobado/usado. |
| `POST` | `/api/v1/projects/{projectId}/members/{memberId}/analytics/generate` | `generateMemberAnalytics()` — Calcula/actualiza métricas del miembro para un rango. |
| `GET`  | `/api/v1/projects/{projectId}/members/{memberId}/analytics` | `getMemberAnalytics()` — Retorna métricas del miembro (`MemberAnalyticsDTO`). |
| `PATCH`| `/api/v1/projects/{projectId}/members/{memberId}/hourly-rate` | `setMemberHourlyRate()` — Define/actualiza la tarifa por hora del miembro. |

### Dependencias

- **Command Services**
  - `ProjectAnalyticsCommandService` — ejecuta *GenerateProjectAnalytics*, *RecalculateRanking*, *UpdateProjectBudget*.
  - `MemberAnalyticsCommandService` — ejecuta *GenerateMemberAnalytics* y *SetMemberHourlyRate*.
- **Query Services**
  - `ProjectAnalyticsQueryService` — obtiene `ProjectAnalytics`.
  - `MemberAnalyticsQueryService` — obtiene `MemberAnalytics`.
- **Assemblers (Resources ↔ DTOs/Commands)**
  - `GenerateProjectAnalyticsCommandFromResourceAssembler`
  - `RecalculateRankingCommandFromResourceAssembler`
  - `UpdateProjectBudgetCommandFromResourceAssembler`
  - `GenerateMemberAnalyticsCommandFromResourceAssembler`
  - `SetMemberHourlyRateCommandFromResourceAssembler`
  - `ProjectAnalyticsDTOAssembler`
  - `MemberAnalyticsDTOAssembler`
  - `RankingResponseAssembler`

---

## DTOs de Entrada/Salida 

- `DateRangeDTO { startDate, endDate }`
- `TaskStatsDTO { total, notStarted, inProgress, done, overdue }`
- `AverageMetricDTO[]` con elementos `{ dimension, code, avgHours }`
- `BudgetUsageDTO { approved, used, variance }`
- `MemberSnapshotDTO { memberId, taskStats, avgCompletionHours, spentHours, hourlyRate, cost }`
- `ProjectAnalyticsDTO { projectId, period, taskStats, avgMetrics, budget, members, bestMemberId, worstMemberId, rankingReason }`
- `MemberAnalyticsDTO { projectId, memberId, period, taskStats, avgMetrics, hourlyRate, spentHours, cost, velocity }`


#### 2.6.1.3. Application Layer: Analítica y Reportes

La Application Layer coordina la lógica que se ejecuta frente a **comandos** y **eventos**.  
Los CommandHandlers procesan solicitudes del usuario (generar/actualizar estadísticas, recalcular ranking, actualizar presupuesto/tarifa).  
Los EventHandlers reaccionan a cambios del sistema (tareas asignadas/completadas/vencidas, cambios de presupuesto o tarifa) para mantener las métricas al día.

---

### Servicio (CommandHandler): ProjectAnalyticsCommandServiceImpl

Atiende comandos relacionados al Proyecto: generación/actualización de métricas agregadas, ranking y presupuesto.

| Método | Descripción |
|---|---|
| `handle(GenerateProjectAnalyticsCommand)` | Calcula o refresca las métricas del proyecto para un periodo (conteos, promedios, costos por miembro) y persiste el resultado. |
| `handle(RecalculateRankingCommand)` | Recalcula `bestMemberId`, `worstMemberId` y `rankingReason` según el criterio/filtros solicitados y actualiza el agregado. |
| `handle(UpdateProjectBudgetCommand)` | Actualiza el presupuesto aprobado/usado y su varianza en las métricas del proyecto. |

---

### Servicio (CommandHandler): MemberAnalyticsCommandServiceImpl

Atiende comandos del Team Member dentro de un proyecto.

| Método | Descripción |
|---|---|
| `handle(GenerateMemberAnalyticsCommand)` | Calcula o refresca las métricas del miembro (conteos, promedios, horas, costo, velocidad) y las persiste. |
| `handle(SetMemberHourlyRateCommand)` | Actualiza la tarifa por hora del miembro y recalcula su costo acumulado para el periodo. |

---

### Servicio (EventHandler): AnalyticsEventHandler

Reacciona a eventos del BC de Gestión de Proyectos y Tareas para mantener las analíticas actualizadas.

| Método | Descripción |
|---|---|
| `handle(TaskAssignedEvent)` | Integra una nueva asignación de tarea; actualiza conteos del miembro y del proyecto. |
| `handle(TaskCompletedEvent)` | Registra una tarea completada; actualiza conteos y promedios de duración. |
| `handle(TaskMarkedOverdueEvent)` | Marca vencidas; ajusta métricas globales y del miembro. |
| `handle(DeadlineChangedEvent)` | Revalida vencimiento y recalcula promedios si corresponde. |
| `handle(ProjectBudgetChangedEvent)` | Sincroniza presupuesto aprobado/usado del proyecto. |
| `handle(MemberHourlyRateChangedEvent)` | Actualiza la tarifa del miembro y recalcula su costo. |

---

### Servicio (QueryHandler): ProjectAnalyticsQueryServiceImpl
Atiende consultas de métricas del Proyecto ya calculadas.

| Método | Descripción |
|---|---|
| `handle(GetProjectAnalyticsQuery)` | Retorna `ProjectAnalytics` del proyecto y periodo indicados (si existe). |
| `handle(GetProjectRankingQuery)` | Devuelve `bestMemberId`, `worstMemberId` y el `rankingReason` actuales del proyecto. |

*Dependencias:*  
- `ProjectAnalyticsRepository`

---

### Servicio (QueryHandler): MemberAnalyticsQueryServiceImpl

Atiende consultas de métricas del Team Member dentro de un proyecto.

| Método | Descripción |
|---|---|
| `handle(GetMemberAnalyticsQuery)` | Retorna `MemberAnalytics` para `projectId` y `memberId` en el periodo dado. |

*Dependencias:*  
- `MemberAnalyticsRepository`


#### 2.6.1.4. Infrastructure Layer: Analítica y Reportes

En la Infrastructure Layer se ubican las clases que interactúan con la base de datos u otros servicios necesarios para persistir y recuperar información clave **de métricas**.  
Aquí se implementan las interfaces de Repositories definidas en el Domain Layer.  

---

### Repository: ProjectAnalyticsRepositoryImpl

Implementación de acceso a datos para `ProjectAnalytics`.

| Método | Tipo de retorno | Visibilidad | Descripción |
|---|---|---|---|
| `findByProjectId(int projectId)` | `Optional<ProjectAnalytics>` | Public | Recupera las métricas agregadas del proyecto para su periodo activo o materializado. |
| `save(ProjectAnalytics aggregate)` | `void` | Public | Inserta o actualiza las métricas del proyecto (taskStats, avgMetrics, budget, ranking). |

---

### Repository: MemberAnalyticsRepositoryImpl

Implementación de acceso a datos para `MemberAnalytics`.

| Método | Tipo de retorno | Visibilidad | Descripción |
|---|---|---|---|
| `findByProjectIdAndMemberId(int projectId, int memberId)` | `Optional<MemberAnalytics>` | Public | Recupera las métricas del miembro dentro del proyecto. |
| `save(MemberAnalytics aggregate)` | `void` | Public | Inserta o actualiza las métricas del miembro (taskStats, avgMetrics, horas, costo, velocidad). |

##### 2.6.1.5. Bounded Context Software Architecture Component Level Diagrams
![ddd](Assets/TB1/C4-componentesv1-AYR.png)


##### 2.6.1.6. Bounded Context Software Architecture Code Level Diagrams
A continuacion se mostraran como se interconectan los componentes a mayor detalle
###### 2.6.1.6.1. Bounded Context Domain Layer Class Diagrams
![ddd](Assets/TB1/Diagrama-Clases-AYR.png)
###### 2.6.1.6.2. Bounded Context Database Design Diagrams

####  2.6.3. Bounded Context:Visualización y Seguimiento

##### 2.6.3.1. Domain Layer

La capa de dominio constituye el núcleo de la aplicación, donde se definen las reglas y modelos que permiten ofrecer a los miembros del equipo una visión clara y organizada del estado de los proyectos y tareas.  
En este contexto, el agregado **VisualizationAggregate** actúa como la raíz que integra tanto los tableros de tareas como las vistas de calendario, garantizando que la información se muestre de forma coherente y en tiempo real.

**Objetivo:** Representar las entidades que permiten la visualización y seguimiento de las tareas y proyectos, asegurando que cada cambio en el estado de una tarea se refleje de manera precisa en tableros y calendarios sincronizados.

---

* **Aggregate: VisualizationAggregate**  
**Descripción:** Este agregado coordina la información proveniente de tableros y calendarios. Centraliza las actualizaciones recibidas de otros bounded contexts (como Gestión de Proyectos y Tareas) y asegura que las vistas se mantengan actualizadas.

|Atributo|Tipo|Descripción|
|:-|:-|:-|
|id|Long|Identificador único del agregado.|
|taskBoard|TaskBoard|Tablero asociado que agrupa tareas en diferentes estados.|
|calendarView|CalendarView|Vista de calendario con eventos relacionados a tareas y proyectos.|

|Método|Descripción|
|:-|:-|
|updateBoard(Task task)|Actualiza el tablero con el nuevo estado de la tarea.|
|updateCalendar(Task task)|Refleja en el calendario las fechas relevantes de la tarea.|
|synchronizeViews()|Asegura que tablero y calendario muestren información coherente.|

---

* **Entity: TaskBoard**  
**Descripción:** Representa un tablero visual donde se agrupan tareas y proyectos en columnas según su estado actual.

|Atributo|Tipo|Descripción|
|:-|:-|:-|
|boardId|Long|Identificador único del tablero.|
|name|String|Nombre asignado al tablero.|
|columns|List<TaskStatus>|Lista de columnas que agrupan tareas según su estado.|

|Método|Descripción|
|:-|:-|
|addColumn(String name)|Agrega una nueva columna al tablero.|
|moveTask(Task task, TaskStatus status)|Mueve una tarea de una columna a otra.|
|refreshBoard()|Refresca la visualización del tablero para reflejar cambios.|

---

* **Entity: CalendarView**  
**Descripción:** Representa una vista de calendario en la que se muestran fechas de inicio, vencimiento y progreso de las tareas.

|Atributo|Tipo|Descripción|
|:-|:-|:-|
|calendarId|Long|Identificador único de la vista calendario.|
|events|List<TimeFrame>|Lista de eventos que representan hitos o tareas con fechas clave.|

|Método|Descripción|
|:-|:-|
|addEvent(TimeFrame event)|Agrega un evento al calendario.|
|updateEvent(Task task)|Modifica las fechas de un evento existente.|
|highlightOverdueTasks()|Resalta visualmente las tareas vencidas.|

---

* **Value Object: TaskStatus**  
**Descripción:** Define el estado de una tarea dentro del flujo de seguimiento.

|Valor|Descripción|
|:-|:-|
|Pendiente|Tarea aún no iniciada.|
|En Progreso|Tarea actualmente en ejecución.|
|Completada|Tarea finalizada exitosamente.|
|Vencida|Tarea cuyo plazo expiró sin completarse.|

---

* **Value Object: TimeFrame**  
**Descripción:** Encapsula las fechas de inicio y vencimiento de una tarea o proyecto.

|Atributo|Tipo|Descripción|
|:-|:-|:-|
|startDate|Date|Fecha de inicio.|
|dueDate|Date|Fecha de vencimiento.|

|Método|Descripción|
|:-|:-|
|isOverdue()|Devuelve `true` si la fecha actual es posterior al vencimiento.|
|remainingDays()|Calcula los días restantes hasta la fecha de vencimiento.|

---

* **Domain Service: VisualizationService**  
**Descripción:** Gestiona la actualización de las vistas (tableros y calendarios) al procesar eventos provenientes de otros bounded contexts.

|Método|Descripción|
|:-|:-|
|processTaskUpdate(Task task)|Procesa un evento de actualización de tarea y actualiza las vistas correspondientes.|
|notifyCriticalChange(Task task)|Comunica a Notificaciones los cambios críticos (ej. tarea vencida).|

---

* **Repository Interfaces**  

- **ITaskBoardRepository**  
  Métodos:  
  - `saveBoard(TaskBoard board)`  
  - `getBoardById(Long id)`  
  - `updateBoard(TaskBoard board)`  

- **ICalendarRepository**  
  Métodos:  
  - `saveCalendar(CalendarView calendar)`  
  - `getCalendarById(Long id)`  
  - `updateCalendar(CalendarView calendar)`  


##### 2.6.3.2. Interface Layer

La capa de interfaz es la encargada de manejar la comunicación entre el usuario y el sistema, así como entre sistemas externos que envían o reciben eventos. Aquí se definen los controladores y consumidores responsables de recibir solicitudes, procesarlas y delegarlas a la capa de dominio.

**Objetivo:** Facilitar la interacción de los usuarios y sistemas externos con las funcionalidades de visualización y seguimiento, asegurando que las operaciones sobre tableros y calendarios se gestionen de forma clara y eficiente.

---

* **Controller: VisualizationController**  
**Descripción:** Expone endpoints REST para acceder y actualizar las vistas de tableros y calendarios de tareas.

|Método|Ruta|Descripción|
|:-|:-|:-|
|getBoard(Long boardId)|GET `/boards/{boardId}`|Obtiene el estado actual de un tablero.|
|getCalendar(Long calendarId)|GET `/calendars/{calendarId}`|Obtiene la vista del calendario asociado a un proyecto.|
|updateTaskStatus(Long taskId, TaskStatus status)|PUT `/tasks/{taskId}/status`|Actualiza el estado de una tarea en tablero y calendario.|
|refreshViews()|POST `/views/refresh`|Fuerza la sincronización entre tablero y calendario.|

---

* **Controller: TaskTrackingController**  
**Descripción:** Controlador orientado al seguimiento de tareas específicas. Permite consultar y visualizar su progreso.

|Método|Ruta|Descripción|
|:-|:-|:-|
|getTaskProgress(Long taskId)|GET `/tasks/{taskId}/progress`|Devuelve el progreso detallado de una tarea.|
|getOverdueTasks()|GET `/tasks/overdue`|Lista todas las tareas vencidas en el sistema.|
|getTeamOverview(Long projectId)|GET `/projects/{projectId}/overview`|Muestra el estado general del equipo en el proyecto.|

---

* **Consumer: TaskEventConsumer**  
**Descripción:** Clase encargada de recibir eventos de actualización de tareas provenientes del bounded context de Gestión de Proyectos y Tareas.

|Evento|Acción|
|:-|:-|
|TaskCreated|Agrega la tarea al tablero y al calendario.|
|TaskUpdated|Actualiza la información de la tarea en las vistas.|
|TaskCompleted|Marca la tarea como completada en tablero y calendario.|
|TaskOverdue|Resalta la tarea vencida y notifica cambios críticos.|

---

* **Consumer: NotificationConsumer**  
**Descripción:** Recibe eventos de Analítica y Reportes o de Notificaciones para reflejar cambios visuales en la interfaz de seguimiento.  

|Evento|Acción|
|:-|:-|
|StatisticsUpdatedEvent|Refresca la vista con estadísticas resumidas.|

##### 2.6.3.3. Application Layer

La capa de aplicación se encarga de coordinar los flujos de procesos del negocio relacionados con la visualización y el seguimiento.
**Objetivo:** Gestionar la lógica de orquestación de procesos, ejecutando comandos y reaccionando a eventos que afectan la visualización de tableros y calendarios, para mantener la información siempre actualizada y consistente.

---

* **Command Handler: UpdateTaskStatusHandler**  
**Descripción:** Maneja el comando para actualizar el estado de una tarea. Se asegura de que los cambios se reflejen tanto en el tablero como en el calendario.  

|Comando|Acción|
|:-|:-|
|UpdateTaskStatusCommand|Valida el cambio de estado de la tarea, lo aplica en el dominio y notifica la actualización a los consumidores visuales.|

---

* **Command Handler: RefreshBoardViewHandler**  
**Descripción:** Ejecuta la acción de refrescar las vistas de un tablero o calendario cuando se solicita manualmente.  

|Comando|Acción|
|:-|:-|
|RefreshBoardViewCommand|Solicita al dominio regenerar las vistas de tablero y calendario para reflejar datos actuales.|

---

* **Event Handler: TaskCreatedEventHandler**  
**Descripción:** Reacciona a la creación de una tarea proveniente del bounded context de Gestión de Proyectos y Tareas.  

|Evento|Acción|
|:-|:-|
|TaskCreatedEvent|Inicia la sincronización para agregar la tarea en las vistas de tablero y calendario.|

---

* **Event Handler: TaskCompletedEventHandler**  
**Descripción:** Gestiona el evento que indica que una tarea ha sido completada.  

|Evento|Acción|
|:-|:-|
|TaskCompletedEvent|Actualiza el tablero y calendario para marcar la tarea como completada y recalcula los indicadores visuales.|

---

* **Event Handler: TaskOverdueEventHandler**  
**Descripción:** Procesa el evento de tarea vencida y resalta el cambio en las vistas visuales.  

|Evento|Acción|
|:-|:-|
|TaskOverdueEvent|Marca la tarea como atrasada en el tablero, actualiza el calendario y emite notificaciones visuales.|



##### 2.6.3.4. Infrastructure Layer
**Objetivo:** Implementar los mecanismos técnicos de persistencia y comunicación externa que aseguren la consistencia y disponibilidad de la información visualizada en tableros y calendarios.

---

* **Repository: TaskViewRepositoryImpl**  
**Descripción:** Implementación concreta del repositorio definido en la capa de dominio. Se encarga de almacenar y recuperar el estado visual de las tareas para tableros y calendarios.  

|Método|Acción|
|:-|:-|
|save(TaskView taskView)|Guarda el estado actualizado de una vista de tarea en la base de datos.|
|findByProjectId(Long projectId)|Recupera todas las vistas de tareas asociadas a un proyecto específico.|
|updateStatus(Long taskId, String status)|Actualiza el estado de una tarea y lo refleja en la persistencia.|
|deleteByTaskId(Long taskId)|Elimina la vista de una tarea del repositorio.|

---

* **Repository: BoardViewRepositoryImpl**  
**Descripción:** Administra la persistencia de configuraciones y estados de los tableros de visualización.  

|Método|Acción|
|:-|:-|
|save(BoardView boardView)|Guarda la configuración actual de un tablero.|
|findByUserId(Long userId)|Recupera el tablero asociado a un usuario.|
|refresh(Long boardId)|Actualiza y sincroniza los datos del tablero desde la base de datos.|

---

* **MessageBroker Adapter: EventConsumer**  
**Descripción:** Clase que escucha los eventos provenientes de otros bounded contexts (como Gestión de Proyectos y Tareas) y los adapta para ser procesados por los Event Handlers en la Application Layer.  

|Evento recibido|Acción|
|:-|:-|
|TaskCreatedEvent|Convierte el mensaje recibido en un evento de dominio interno y lo pasa al Event Handler correspondiente.|
|TaskCompletedEvent|Adapta el evento para actualizar las vistas locales de las tareas.|
|TaskOverdueEvent|Procesa el mensaje y lo reenvía para resaltar tareas vencidas.|

---

* **Database Adapter: TaskViewEntity**  
**Descripción:** Clase de mapeo (ORM) que traduce los objetos de dominio como `TaskView` a entidades de persistencia en la base de datos relacional.  

|Atributo|Tipo|Descripción|
|:-|:-|:-|
|id|Long|Identificador único de la vista de tarea.|
|taskId|Long|Identificador de la tarea original.|
|status|String|Estado actual de la tarea (pendiente, en progreso, completada, vencida).|
|lastUpdated|Date|Fecha y hora de la última sincronización.|

##### 2.6.3.5. Bounded Context Software Architecture Component Level Diagrams
![ddd](Assets/TB1/ddd.png)

##### 2.6.3.6. Bounded Context Software Architecture Code Level Diagrams

###### 2.6.3.6.1. Bounded Context Domain Layer Class Diagrams

![ddd](Assets/TB1/domain.png)

###### 2.6.3.6.2. Bounded Context Database Design Diagrams


#### 2.6.4. Bounded Context: Gestión de Proyectos y Tareas

##### 2.6.1.1. Domain Layer

El Domain Layer de este bounded context concentra las reglas de negocio esenciales relacionadas con la creación, asignación y seguimiento de proyectos y tareas. Esta capa se encarga de representar los conceptos fundamentales mediante aggregates, entities, value objects, domain services y repositories.

1. **Aggregate: Project**

**Descripción:**

El proyecto es la raíz de agregado, encargado de mantener la consistencia de su información interna y de las tareas que le pertenecen. A través del DateRange asegura que las fechas sean válidas y mediante su lista de tareas gestiona el ciclo de vida de estas.

| Atributo   | Tipo          | Descripción                                      |
|------------|---------------|--------------------------------------------------|
| projectId  | int           | Identificador único del proyecto.                |
| title      | String        | Nombre del proyecto.                             |
| description| String        | Descripción general.                             |
| dateRange  | DateRange     | Período de inicio y fin del proyecto.            |
| status     | String        | Estado del proyecto (activo, completado, cancelado). |
| tasks      | List<Task>    | Conjunto de tareas asociadas al proyecto.        |
| ownerId    | int           | Identificador del usuario responsable.           |

**Métodos:**

- addTask(Task task): Agrega una nueva tarea validando que esté dentro del rango de fechas.
- removeTask(int taskId): Elimina una tarea del proyecto.
- updateStatus(String newStatus): Cambia el estado del proyecto.
- getProgress(): Retorna el porcentaje de avance calculado en función de las tareas.

2. **Entity: Task**

**Descripción:**

Una tarea representa una unidad de trabajo dentro de un proyecto. Mantiene atributos como prioridad, estado y las fechas de asignación y finalización.

| Atributo       | Tipo           | Descripción                                                |
|----------------|----------------|------------------------------------------------------------|
| taskId         | int            | Identificador único de la tarea.                           |
| title          | String         | Nombre de la tarea.                                        |
| description    | String         | Detalle de la tarea.                                       |
| dueDate        | LocalDate      | Fecha límite para completarla.                             |
| priority       | PriorityLevel  | Nivel de prioridad.                                        |
| status         | TaskStatus     | Estado actual de la tarea.                                 |
| assignedUserId | int            | Identificador del usuario asignado.                        |
| assignedAt     | LocalDateTime  | Fecha y hora en que fue asignada.                          |
| completedAt    | LocalDateTime? | Fecha y hora en que fue completada (opcional).             |

**Métodos:**

- updateStatus(TaskStatus newStatus): Cambia el estado de la tarea.
- assignUser(int userId):  Asigna un responsable.
- markAsCompleted():  Marca la tarea como finalizada registrando completedAt.

3. **Value Object: TaskStatus**

**Descripción:**

Representa el estado de una tarea. Se define como un objeto de valor para mantener consistencia.

**Valores posibles:**

- TO_DO
- IN_PROGRESS
- DONE

4. **Value Object: PriorityLevel**

**Descripción:**

Define la importancia relativa de una tarea.

**Valores posibles:**

- HIGH
- MEDIUM
- LOW

5. **Value Object: DateRange**

**Descripción:**

Intervalo de fechas que determina el tiempo de duración de un proyecto.

| Atributo  | Tipo       | Descripción             |
|-----------|------------|-------------------------|
| startDate | LocalDate  | Fecha de inicio.        |
| endDate   | LocalDate  | Fecha de finalización.  |

**Reglas clave:**

- startDate debe ser anterior o igual a endDate.

6. **Domain Service: TaskAssignmentService**

**Descripción:**

Se encarga de validar y asignar una tarea a un usuario del proyecto, asegurando que el miembro pertenezca al equipo.

**Métodos:**

- assignTask(Task task, int userId): Asigna la tarea validando que el usuario pertenece al proyecto.

7. **Domain Service: ProjectProgressService**

**Descripción:**

Calcula el porcentaje de avance de un proyecto en función del estado de sus tareas.

**Métodos:**

- calculateProgress(Project project): Retorna el avance como un valor numérico.

8. **Repository: ProjectRepository**

**Descripción:**

Interfaz encargada de la persistencia de proyectos.

**Métodos:**

- save(Project project): Guarda o actualiza un proyecto.
- findById(int projectId): Busca un proyecto por su ID.
- findAll(): Lista todos los proyectos.
- delete(int projectId): Elimina un proyecto.

9. **Repository: TaskRepository**

**Descripción:**

Interfaz encargada de la persistencia de tareas.

**Métodos:**

- save(Task task): Guarda o actualiza una tarea.
- findById(int taskId): Busca una tarea por su ID.
- findByProject(int projectId): Obtiene todas las tareas de un proyecto.
- updateStatus(int taskId, TaskStatus newStatus): Cambia el estado de una tarea.
- delete(int taskId): Elimina una tarea.

##### 2.6.1.2. Interface Layer

La Interface Layer es la capa que expone los endpoints de la aplicación para la gestión de proyectos y tareas. Su principal función es permitir que los usuarios interactúen con el sistema mediante peticiones HTTP. En esta capa, los controladores reciben las solicitudes, las validan y se encargan de coordinar con los servicios de la capa de dominio para ejecutar las acciones requeridas. Es importante señalar que aquí no se implementan reglas de negocio, sino que se orquesta la comunicación entre la capa de presentación y la lógica del dominio.

**Controlador: ProjectsController**

**Descripción:**

El ProjectsController maneja los endpoints relacionados con la creación, actualización, consulta y eliminación de proyectos. A través de este controlador los usuarios pueden registrar nuevos proyectos, actualizar información, consultar detalles específicos o eliminar proyectos existentes.

| Método         | Ruta                           | Descripción                                                                                                                                 |
|----------------|--------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------|
| createProject  | POST /api/v1/projects          | Permite registrar un nuevo proyecto en el sistema. Recibe un objeto `CreateProjectResource`, lo convierte en un comando y lo envía al servicio de comandos. |
| updateProject  | PUT /api/v1/projects/{projectId} | Permite actualizar los datos de un proyecto específico. Recibe un objeto `UpdateProjectResource` y llama al servicio para modificar el proyecto. |
| getAllProjects | GET /api/v1/projects           | Devuelve la lista completa de proyectos registrados en el sistema.                                                                          |
| getProjectById | GET /api/v1/projects/{projectId} | Obtiene los detalles de un proyecto específico identificado por su ID. Si no existe, retorna un error 404.                                  |
| deleteProject  | DELETE /api/v1/projects/{projectId} | Elimina un proyecto existente. Si la operación es exitosa, devuelve un mensaje de confirmación.                                               |

**Dependencias:**

| Dependencia                                  | Descripción                                                                                          |
|----------------------------------------------|------------------------------------------------------------------------------------------------------|
| ProjectCommandService                        | Servicio encargado de manejar los comandos relacionados con la creación, actualización y eliminación de proyectos. |
| ProjectQueryService                          | Servicio encargado de manejar las consultas relacionadas con proyectos.                              |
| CreateProjectCommandFromResourceAssembler    | Convierte recursos REST en comandos de creación de proyectos.                                        |
| UpdateProjectCommandFromResourceAssembler    | Convierte recursos REST en comandos de actualización de proyectos.                                  |
| ProjectResourceFromEntityAssembler           | Convierte entidades de proyecto en recursos REST para la respuesta.                                  |

**Controlador: TasksController**

**Descripción:**

El TasksController maneja los endpoints relacionados con la gestión de tareas dentro de los proyectos. A través de este controlador, los usuarios pueden registrar nuevas tareas, actualizarlas, consultar su información, marcarlas como completadas o eliminarlas.

| Método              | Ruta                                  | Descripción                                                                                  |
|---------------------|---------------------------------------|----------------------------------------------------------------------------------------------|
| createTask          | POST /api/v1/tasks                    | Permite registrar una nueva tarea en el sistema. Recibe un objeto CreateTaskResource y lo convierte en un comando. |
| updateTask          | PUT /api/v1/tasks/{taskId}            | Permite actualizar los datos de una tarea específica. Recibe un objeto UpdateTaskResource y llama al servicio para modificar la tarea. |
| getAllTasks         | GET /api/v1/tasks                     | Devuelve la lista completa de tareas existentes.                                             |
| getTaskById         | GET /api/v1/tasks/{taskId}            | Obtiene los detalles de una tarea específica por su ID. Si no existe, retorna un error 404.  |
| markTaskAsCompleted | PATCH /api/v1/tasks/{taskId}/complete | Marca una tarea como completada, actualizando su estado y fecha de finalización.             |
| deleteTask          | DELETE /api/v1/tasks/{taskId}         | Elimina una tarea existente del sistema.                                                     |

**Dependencias:**

| Dependencia                          | Descripción                                                                                   |
|--------------------------------------|-----------------------------------------------------------------------------------------------|
| TaskCommandService                   | Servicio encargado de manejar los comandos relacionados con la creación, actualización, eliminación y finalización de tareas. |
| TaskQueryService                     | Servicio encargado de manejar las consultas relacionadas con tareas.                          |
| CreateTaskCommandFromResourceAssembler | Convierte recursos REST en comandos de creación de tareas.                                    |
| UpdateTaskCommandFromResourceAssembler | Convierte recursos REST en comandos de actualización de tareas.                               |
| TaskResourceFromEntityAssembler      | Convierte entidades de tarea en recursos REST para la respuesta.                              |

##### 2.6.1.3. Application Layer

La Application Layer es la responsable de orquestar los procesos de negocio dentro del bounded context de Gestión de Proyectos y Tareas.
En esta capa se implementan los Command Handlers y Query/Event Handlers, los cuales se encargan de recibir comandos o consultas, coordinar con el dominio y los repositorios, y devolver respuestas o provocar cambios en el sistema.
Aquí no se aplican directamente las reglas de negocio (que pertenecen al dominio), sino que se gestionan los flujos de proceso, asegurando que cada acción se ejecute en el orden correcto y con las dependencias adecuadas.

**Clase: ProjectCommandServiceImpl**

**Descripción:**

Implementación del servicio de comandos para las operaciones de escritura relacionadas con proyectos. Gestiona la creación, actualización y eliminación de proyectos, coordinando con el agregado Project y el repositorio correspondiente.

| Método                          | Descripción                                                                                  |
|---------------------------------|----------------------------------------------------------------------------------------------|
| handle(CreateProjectCommand)     | Crea un nuevo proyecto con su información básica (nombre, descripción, rango de fechas).     |
| handle(UpdateProjectCommand)     | Actualiza los datos principales de un proyecto ya existente.                                 |
| handle(DeleteProjectCommand)     | Elimina un proyecto, siempre que no tenga dependencias críticas activas.                     |
| handle(AssignTaskToProjectCommand) | Asocia una tarea existente a un proyecto específico.                                        |

**Dependencias:**

| Dependencias                                             | Descripción                                                                                     |
|----------------------------------------------------------|-------------------------------------------------------------------------------------------------|
| ProjectRepository                                        | Repositorio encargado de acceder y persistir los datos de proyectos en la base de datos.       |
| TaskRepository                                           | Repositorio utilizado para validar y consultar tareas antes de asignarlas a proyectos.         |
| CreateProjectCommand                                     | Comando que representa la acción de crear un nuevo proyecto con su información básica.         |
| UpdateProjectCommand                                     | Comando que representa la acción de actualizar los datos de un proyecto existente.             |
| DeleteProjectCommand                                     | Comando que representa la acción de eliminar un proyecto del sistema.                          |
| AssignTaskToProjectCommand                               | Comando que representa la acción de asociar una tarea existente a un proyecto específico.      |

**Clase: TaskCommandServiceImpl**

**Descripción:**

Implementación del servicio de comandos para operaciones de escritura relacionadas con tareas. Gestiona la creación, actualización, asignación y finalización de tareas, coordinando con el repositorio y el agregado Task.

| Método                       | Descripción                                                                                     |
|-------------------------------|-------------------------------------------------------------------------------------------------|
| handle(CreateTaskCommand)     | Crea una nueva tarea vinculada a un proyecto y asigna un responsable.                           |
| handle(UpdateTaskCommand)     | Actualiza información de una tarea existente, incluyendo nombre, descripción y prioridad.      |
| handle(DeleteTaskCommand)     | Elimina una tarea del sistema.                                                                 |
| handle(CompleteTaskCommand)   | Marca una tarea como completada y registra la fecha y hora de finalización.                     |
| handle(AssignUserToTaskCommand)| Asigna un usuario específico a una tarea determinada.                                          |

**Dependencias:**

| Dependencia                                                         | Descripción                                                                                     |
|----------------------------------------------------------------------|-------------------------------------------------------------------------------------------------|
| TaskRepository                                                       | Repositorio encargado del acceso a los datos de tareas, permitiendo CRUD y consultas específicas. |
| ProjectRepository                                                    | Repositorio para validar la existencia de proyectos antes de crear o asignar tareas.            |
| NotificationService                                                  | Servicio encargado de enviar notificaciones a los usuarios cuando se asigna o completa una tarea. |
| CreateTaskCommand                                                    | Comando que representa la acción de crear una nueva tarea dentro del sistema.                  |
| UpdateTaskCommand                                                    | Comando que representa la acción de actualizar los datos de una tarea existente.               |
| DeleteTaskCommand                                                    | Comando que representa la acción de eliminar una tarea del sistema.                             |
| CompleteTaskCommand                                                  | Comando que representa la acción de marcar una tarea como completada y registrar su fecha de finalización. |
| AssignUserToTaskCommand                                              | Comando que representa la acción de asignar un usuario específico a una tarea determinada.     |

**Clase: ProjectQueryServiceImpl**

**Descripción:**

Implementación del servicio de consultas para obtener información de los proyectos. Gestiona consultas de lectura sin modificar el estado del sistema.

| Método                   | Descripción                                                      |
|---------------------------|------------------------------------------------------------------|
| handle(GetProjectByIdQuery) | Obtiene los detalles completos de un proyecto por su ID.        |
| handle(ListProjectsQuery)   | Devuelve todos los proyectos registrados en el sistema.         |
| handle(GetProjectTasksQuery)| Recupera todas las tareas vinculadas a un proyecto específico. |

**Dependencias:**

| Dependencia                         | Descripción                                                                 |
|-------------------------------------|-----------------------------------------------------------------------------|
| ProjectRepository                    | Repositorio encargado del acceso y manipulación de datos de proyectos.      |
| GetProjectByIdQuery                  | Consulta que permite obtener los detalles completos de un proyecto por su ID.|
| ListProjectsQuery                    | Consulta que devuelve todos los proyectos registrados en el sistema.       |
| GetProjectTasksQuery                 | Consulta que recupera todas las tareas asociadas a un proyecto específico. |

**Clase: TaskQueryServiceImpl**

**Descripción:**

Implementación del servicio de consultas para obtener información de las tareas. Facilita la recuperación de tareas por diferentes criterios.

| Método                          | Descripción                                                                 |
|---------------------------------|-----------------------------------------------------------------------------|
| handle(GetTaskByIdQuery)         | Devuelve los detalles de una tarea específica según su ID.                  |
| handle(ListTasksByProjectQuery)  | Recupera todas las tareas asociadas a un proyecto determinado.             |
| handle(ListTasksByUserQuery)     | Obtiene todas las tareas asignadas a un usuario específico.                 |

**Dependencias**

| Dependencia                        | Descripción                                                                 |
|-----------------------------------|-----------------------------------------------------------------------------|
| TaskRepository                     | Repositorio encargado de acceder y manipular los datos de las tareas.       |
| GetTaskByIdQuery                   | Consulta que permite obtener los detalles completos de una tarea por su ID. |
| ListTasksByProjectQuery            | Consulta que permite recuperar todas las tareas asociadas a un proyecto.   |
| ListTasksByUserQuery               | Consulta que permite obtener todas las tareas asignadas a un usuario específico. |

**Clase: TaskEventHandler**

**Descripción:**

Implementación de un manejador de eventos que responde a cambios en el estado de las tareas. Se utiliza para disparar acciones secundarias cuando una tarea se crea o se completa.

| Evento           | Descripción                                                                                  |
|-----------------|----------------------------------------------------------------------------------------------|
| onTaskCreated    | Al crearse una tarea, envía una notificación al usuario asignado.                             |
| onTaskCompleted  | Cuando una tarea se marca como completada, actualiza métricas del proyecto y envía confirmación. |

**Dependencias:**

| Dependencia         | Descripción                                                       |
|--------------------|-------------------------------------------------------------------|
| NotificationService | Envía notificaciones a los usuarios.                               |
| ProjectRepository   | Actualiza métricas relacionadas con el avance de proyectos.       |


##### 2.6.1.4. Infrastructure Layer

En el bounded context de Gestión de Proyectos y Tareas, la infraestructura se centra principalmente en el acceso a la base de datos interna, donde se almacenan las entidades principales (Project y Task).
En esta capa se definen las implementaciones concretas de los Repositories declarados en la capa de dominio. Estas implementaciones permiten realizar operaciones CRUD sobre proyectos y tareas, asegurando la persistencia de los datos y facilitando su recuperación cuando son requeridos por la capa de aplicación.

**Clase: ProjectRepository**

**Descripción:**

Repositorio encargado de la persistencia y gestión de datos relacionados con proyectos. Define las operaciones CRUD y consultas específicas para proyectos.

| Método         | Descripción                                                |
|----------------|------------------------------------------------------------|
| save(ProjectEntity)  | Persiste un nuevo proyecto o actualiza uno existente. |
| deleteById(Long)     | Elimina un proyecto por su identificador único.      |
| findById(Long)       | Recupera un proyecto completo a partir de su identificador. |
| findAll()            | Lista todos los proyectos registrados en el sistema. |

**Clase: TaskRepository**

**Descripción:**

Repositorio encargado de la persistencia y gestión de datos relacionados con tareas. Define las operaciones CRUD y consultas específicas para tareas.

| Método             | Descripción                                                   |
|-------------------|---------------------------------------------------------------|
| save(TaskEntity)   | Persiste una nueva tarea o actualiza una existente.          |
| deleteById(Long)   | Elimina una tarea por su identificador único.                |
| findById(Long)     | Recupera una tarea completa a partir de su identificador.    |
| findByProjectId(Long) | Obtiene todas las tareas asociadas a un proyecto específico. |
| findAll()          | Lista todas las tareas registradas en el sistema.            |

**Dependencias**

| Dependencia   | Descripción                                                                 |
|---------------|-----------------------------------------------------------------------------|
| ProjectEntity | Clase que representa a un proyecto y sus atributos principales.            |
| TaskEntity    | Clase que representa a una tarea con su respectiva relación a un proyecto. |
| Database      | Sistema de gestión de base de datos utilizado para almacenar y consultar la información persistente. |

##### 2.6.1.5. Bounded Context Software Architecture Component Level Diagrams

![ddd](Assets/TB1/ComponentDiagramProjectsAndTasks.png)

##### 2.6.1.6. Bounded Context Software Architecture Code Level Diagrams

###### 2.6.1.6.1. Bounded Context Domain Layer Class Diagrams

![ddd](Assets/TB1/ClassDiagramProjectsAndTasks.png)

###### 2.6.1.6.2. Bounded Context Database Design Diagrams

![ddd](Assets/TB1/DatabaseDiagramProjectsAndTasks.png)

#### 2.6.5. Bounded Context: Notificaciones

##### 2.6.5.1. Domain Layer

En el Domain Layer del contexto de Notificaciones, los agregados principales son Notification y User.
Estos representan los elementos clave para la gestión de mensajes dentro de la plataforma, asegurando que los usuarios sean alertados, informados o recordados sobre eventos relevantes.

Las notificaciones (Notification) encapsulan la información necesaria para ser entregadas (tipo, contenido, estado de lectura, timestamp), mientras que las preferencias del usuario (User) permiten personalizar la forma en que estas se reciben.
La lógica de negocio central se concentra en el NotificationService, responsable de validar y enviar notificaciones de acuerdo con las reglas y preferencias configuradas.

Justificación:
Separar la creación, validación y entrega de notificaciones permite un manejo modular y reutilizable, garantizando coherencia y consistencia en la experiencia del usuario. El uso de un servicio de dominio asegura que todas las notificaciones respeten las reglas definidas y se envíen conforme a la configuración de cada usuario. 

Aggregate: Notification

| Atributo            | Tipo                      | Visibilidad | Descripción |
|---------------------|---------------------------|-------------|-------------|
| `notificationId`    | Int                      | Private     | Identificador único de la notificación. |
| `userId`            | Long                      | Private     | ID del usuario destinatario. |
| `title`        | String        | Private     | Título de la notificación. |
| `message`    | String     | Private     | Contenido principal del mensaje. |
| `type`       | NotificationType   | Private     | Tipo de notificación (INFO, TASK, REMINDER, ALERT). |
| `timestamp`     | LocalDateTime | Private     | Fecha y hora en que fue creada. |

Métodos

| Atributo            | Tipo                      | Visibilidad | Descripción |
|---------------------|---------------------------|-------------|-------------|
| `send()`    | void                      | Public     | Inicia el envío de la notificación según el canal configurado. |
| `isRead()`            | Boolean                      | Public     | Verifica si la notificación fue leída. |

Value Object: NotificationType

| Atributo        | Tipo               | Descripción |
|-----------------|--------------------|-------------|
| `INFO`  | String             | Notificación informativa general. |
| `TASK`  | String             | Relacionado con tareas asignadas o completadas. |
| `REMINDER`  | String             | Recordatorio de eventos o plazos próximos. |
| `ALERT`        | String | Mensaje de advertencia o situación importante. |

##### 2.6.5.2. Interface Layer

La Interface Layer expone los endpoints REST (JSON) que permiten a la interfaz web y otros módulos enviar, consultar y actualizar notificaciones.
En esta capa no hay reglas de negocio: los controladores reciben las peticiones, validan datos de entrada y delegan a la Application Layer.

Controlador: NotificationController

| Método        | Ruta               | Descripción |
|-----------------|--------------------|-------------|
| `POST`  | `/api/v1/users/{userId}/notifications`             | `sendNotification()` Envía una nueva notificación al usuario. |
| `GET`  | `/api/v1/users/{userId}/notifications`             | `getUserNotifications()` Lista todas las notificaciones del usuario (opcionalmente filtradas por estado o rango de fechas). |
| `GET`  | `//api/v1/notifications/{notificationId}`             | `getNotificationById()` Recupera una notificación por su identificador. |
| `DELETE`  | `/api/v1/notifications/{notificationId}`             | `deleteNotification()` Elimina una notificación existente. |


##### 2.6.5.3. Application Layer

La Application Layer coordina la lógica que se ejecuta frente a comandos (enviar, leer, eliminar) y consultas (obtener notificaciones, preferencias).
Los CommandHandlers procesan solicitudes explícitas, mientras que los EventHandlers reaccionan a eventos de otros bounded contexts (por ejemplo, creación de tareas o asignaciones de grupo).

Servicio (CommandHandler): NotificationCommandServiceImpl

| Método          |  Descripción |
|-----------------|---------------|
| `handle(SendNotificationCommand)`          | Crea y envía una notificación según el tipo y las preferencias del usuario. |
| `handle(DeleteNotificationCommand)`           | Elimina una notificación del repositorio. |

Servicio (QueryHandler): NotificationQueryServiceImpl

| Método          |  Descripción |
|-----------------|---------------|
| `handle(GetUserNotificationsQuery)`          | Retorna todas las notificaciones de un usuario. |
| `handle(GetNotificationByIdQuery)`           | Recupera una notificación específica. |

EventHandlers

TaskAssignedEventHandler — Envía una notificación al usuario asignado a una tarea.

GroupJoinedEventHandler — Notifica al coordinador cuando un nuevo miembro se une a un grupo.

##### 2.6.5.4. Infrastructure Layer

La Infrastructure Layer contiene las implementaciones concretas para persistir notificaciones y preferencias, así como adaptadores de envío a servicios externos (correo, push, etc.).

| Método        | Retorno               | Descripción |
|-----------------|--------------------|-------------|
| `findByUserId(userId: Int)`  | `List<Notification>`             | Recupera todas las notificaciones de un usuario. |
| `findById(notificationId: Int)`  | `List<Notification>`             | Busca una notificación por su identificador. |
| `save(notification: Notification)`  | void            | Persiste una nueva notificación. |
| `delete(notificationId: Int)`  | void           | Elimina una notificación. |

##### 2.6.5.5. Bounded Context Software Architecture Component Level Diagrams

##### 2.6.5.6. Bounded Context Software Architecture Code Level Diagrams

###### 2.6.5.6.1. Bounded Context Domain Layer Class Diagrams

###### 2.6.5.6.2. Bounded Context Database Design Diagrams
